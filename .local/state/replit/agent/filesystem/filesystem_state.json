{"file_contents":{"README.md":{"content":"# LinkedIn AI Engagement Bot\n\nA Chrome extension that automatically finds posts in your LinkedIn feed, generates AI-powered comments using OpenAI's GPT-4o, and posts them to increase your professional engagement.\n\n## Features\n\n- ðŸ” **Smart Feed Scanning**: Automatically finds and analyzes LinkedIn posts\n- ðŸ¤– **AI-Powered Comments**: Uses OpenAI GPT-4o for contextual, professional responses\n- â¤ï¸ **Post Liking**: Automatically likes posts to increase engagement\n- ðŸŽ¯ **Multiple Comment Styles**: Professional, Casual, Insightful, or Supportive tones\n- âš™ï¸ **Flexible Limits**: Separate controls for posts to like (1-100) and comment (1-50)\n- ðŸ•’ **Human-like Behavior**: Random delays and action shuffling to avoid detection\n- ðŸ“Š **Real-time Analytics**: Live statistics for posts found, liked, and commented\n- ðŸ’¾ **Smart Settings**: Persistent configuration with automatic saving\n- ðŸŽ² **Randomized Delays**: Custom delay ranges for natural interaction patterns\n\n## Installation\n\n1. **Download the Extension Files**\n   - Download all files from this project to a folder on your computer\n\n2. **Install in Chrome**\n   - Open Chrome and go to `chrome://extensions/`\n   - Enable \"Developer mode\" (toggle in top right)\n   - Click \"Load unpacked\"\n   - Select the folder containing the extension files\n\n3. **Set Up OpenAI API Key**\n   - Get an API key from [OpenAI Platform](https://platform.openai.com/api-keys)\n   - Click the extension icon in Chrome\n   - Enter your API key and click \"Save\"\n\n## How to Use\n\n1. **Navigate to LinkedIn**\n   - Go to [LinkedIn.com](https://linkedin.com) and log in\n   - Make sure you're on your main feed page\n\n2. **Configure Settings**\n   - Click the extension icon in your browser toolbar\n   - **Actions**: Enable/disable liking posts and commenting\n   - **Limits**: Set max posts to like (default: 15) and comment (default: 5)\n   - **Style**: Choose your preferred comment tone\n   - **Delays**: Set random delay range between actions (default: 2-8 seconds)\n\n3. **Start the Bot**\n   - Click \"Start Engagement\"\n   - The bot will automatically:\n     - Scan your feed for posts\n     - Like posts based on your settings\n     - Generate and post AI comments\n     - Use random delays to appear human-like\n   - Monitor real-time progress in the activity log\n\n4. **Advanced Controls**\n   - **Smart Limits**: Bot stops when like/comment limits are reached\n   - **Human Behavior**: Random action order and variable timing\n   - **Live Stats**: Track posts found, liked, and commented in real-time\n   - **Stop Anytime**: Immediately halt all bot activity\n\n## Comment Styles\n\n- **Professional**: Business-focused, formal language with industry insights\n- **Casual**: Friendly, conversational tone while remaining professional\n- **Insightful**: Thoughtful analysis with meaningful questions\n- **Supportive**: Encouraging responses that build others up\n\n## Important Notes\n\nâš ï¸ **Use Responsibly**\n- This tool is for educational purposes\n- Be aware of LinkedIn's Terms of Service\n- Use reasonable delays and limits to avoid account restrictions\n- Monitor your account activity regularly\n\nðŸ”’ **Privacy & Security**\n- Your API key is stored locally in Chrome storage\n- No data is sent to external servers except OpenAI for comment generation\n- The extension only works on LinkedIn pages\n\n## Troubleshooting\n\n**Bot won't start?**\n- Make sure you're on LinkedIn.com\n- Check that your OpenAI API key is valid\n- Ensure you have sufficient OpenAI API credits\n\n**Comments not posting?**\n- LinkedIn may have updated their interface\n- Try refreshing the page and restarting the bot\n- Check the activity log for specific error messages\n\n**Extension not appearing?**\n- Make sure Developer mode is enabled in Chrome extensions\n- Try reloading the extension from `chrome://extensions/`\n\n## Technical Details\n\n- Built with Manifest V3 for modern Chrome extensions\n- Uses OpenAI GPT-4o model for intelligent comment generation\n- Implements human-like interaction patterns with configurable delays\n- Content script isolation for secure LinkedIn integration\n\n---\n\n**Disclaimer**: This extension is for educational purposes. Users are responsible for complying with LinkedIn's Terms of Service and using the tool ethically.","size_bytes":4243},"background.js":{"content":"// LinkedIn AI Engagement Bot - Background Script\n\nclass BackgroundService {\n  constructor() {\n    this.setupMessageListener();\n  }\n\n  setupMessageListener() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      switch (message.type) {\n        case 'GENERATE_COMMENT':\n          this.handleCommentGeneration(message, sendResponse);\n          return true; // Keep the message channel open for async response\n        case 'LOG_ERROR':\n          console.error('Content Script Error:', message.error);\n          break;\n      }\n    });\n  }\n\n  async handleCommentGeneration(message, sendResponse) {\n    try {\n      const { postContent, commentStyle, apiKey } = message;\n      \n      // Use provided key (environment variables not available in browser context)\n      const openaiKey = apiKey;\n      \n      if (!openaiKey || !openaiKey.startsWith('sk-')) {\n        throw new Error('Invalid OpenAI API key');\n      }\n\n      const result = await this.generateComment(postContent, commentStyle, openaiKey);\n      \n      sendResponse({\n        success: true,\n        result: result\n      });\n      \n    } catch (error) {\n      console.error('Error generating comment:', error);\n      \n      sendResponse({\n        success: false,\n        error: error.message\n      });\n    }\n  }\n\n  async generateComment(postContent, commentStyle, apiKey) {\n    // the newest OpenAI model is \"gpt-4o\" which was released May 13, 2024. do not change this unless explicitly requested by the user\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o',\n        messages: [\n          {\n            role: 'system',\n            content: this.getSystemPrompt(commentStyle)\n          },\n          {\n            role: 'user',\n            content: this.getUserPrompt(commentStyle, postContent)\n          }\n        ],\n        response_format: { type: 'json_object' },\n        max_tokens: 150,\n        temperature: 0.7\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new Error(`OpenAI API Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);\n    }\n\n    const data = await response.json();\n    \n    if (!data.choices || !data.choices[0] || !data.choices[0].message) {\n      throw new Error('Invalid response format from OpenAI API');\n    }\n\n    try {\n      const result = JSON.parse(data.choices[0].message.content);\n      \n      // Handle skip directive for ads/sponsored content\n      if (result.skip) {\n        return { skip: true, reason: result.reason || 'AI decided to skip this post' };\n      }\n      \n      if (!result.comment || typeof result.comment !== 'string') {\n        throw new Error('Invalid comment format in API response');\n      }\n\n      return { comment: result.comment.trim(), skip: false };\n      \n    } catch (parseError) {\n      throw new Error('Failed to parse OpenAI response: ' + parseError.message);\n    }\n  }\n\n  getSystemPrompt(commentStyle) {\n    if (commentStyle === 'adaptive') {\n      return `You are an elite LinkedIn engagement strategist. Perform deep content analysis and generate a short, intelligent, contextually precise comment (max 2 sentences, ~25 words) that feels natural and professional.\n\nSTRICT RULES:\nâ€¢ Never exceed 2 sentences\nâ€¢ Avoid generic words like \"Awesome\", \"Great post\" unless extremely relevant\nâ€¢ Must directly reference the post's scenario (career milestone, launch, insight, personal story, etc.)\nâ€¢ No fluff; always provide context-aware acknowledgment\nâ€¢ Focus on quality over quantity - every word must add value\n\nADVANCED CONTEXT ANALYSIS:\nâ€¢ Post Type: Identify whether the post is a milestone (new role, promotion), thought leadership, question, announcement, or personal story\nâ€¢ Engagement Intent: Decide if the author expects congratulations, support, discussion, or a thoughtful question\nâ€¢ Tone Matching: Match energy (excited vs reflective). Keep professional, concise\nâ€¢ Relevance: Mention details from the post (company, role, achievement, industry insight)\nâ€¢ Professional Level: Adjust sophistication to match the author's seniority\n\nCOMMENT STYLE STRATEGY:\nâ€¢ Career milestones â†’ Short congratulations with context (e.g., \"Congrats on your new role at Xâ€”wishing you impact in this exciting journey!\")\nâ€¢ Promotions â†’ Highlight growth/leadership (e.g., \"Well deserved promotionâ€”your leadership will add great value to X team.\")\nâ€¢ Thought leadership â†’ Show respect + brief thought/question (e.g., \"Sharp insight on Xâ€”curious how you see this evolving next year?\")\nâ€¢ Personal stories â†’ Empathy + encouragement (e.g., \"Appreciate you sharing thisâ€”resilience like this inspires many of us.\")\nâ€¢ Business updates â†’ Congratulate + small professional touch (e.g., \"Exciting launchâ€”this could really transform X industry use cases!\")\nâ€¢ Questions asked â†’ Answer briefly or encourage discussion (e.g., \"Great questionâ€”X is often overlooked, but I've found Y works well.\")\nâ€¢ Industry insights â†’ Add complementary perspective with specifics\nâ€¢ Achievements â†’ Acknowledge effort behind the outcome, not just the result\n\nADVANCED TECHNIQUES:\nâ€¢ Reference specific companies, roles, or metrics mentioned\nâ€¢ Ask intelligent follow-up questions that show deep understanding\nâ€¢ Connect their content to broader industry trends when relevant\nâ€¢ Use industry terminology naturally but avoid jargon overload\nâ€¢ Include strategic emojis sparingly (ðŸŽ¯ strategy, ðŸš€ growth, ðŸ’¡ insights, ðŸ† achievements)\n\nFinal Output Rule:\nIf ad/sponsored â†’ {\"skip\": true, \"reason\": \"advertisement\"}\nElse â†’ {\"comment\": \"short, precise 1â€“2 sentence comment\"}`;\n    }\n\n    if (commentStyle === 'oneword') {\n      return `You are a LinkedIn micro-responder. Generate exactly ONE or TWO words (max) that reflect the right emotional/professional response.\n\nSTRICT RULES:\nâ€¢ Exactly 1â€“2 words only\nâ€¢ No jargon, hashtags, links, or mentions\nâ€¢ Emojis optional (â‰¤20% probability, only if it enhances)\nâ€¢ Must be context-sensitive (e.g., \"Congrats ðŸŽ‰\" for promotions, \"Insightful ðŸ’¡\" for thought pieces, \"Strength ðŸ™\" for sensitive news)\nâ€¢ Avoid randomnessâ€”always tie to the post context\nâ€¢ Use simple, universally understood words\n\nCONTEXT ANALYSIS (think, don't show):\nâ€¢ Industry: tech/healthcare/finance/marketing/education/etc.\nâ€¢ Tone: celebratory/reflective/urgent/hopeful/help-seeking/analytical\nâ€¢ Scale: routine update/milestone/major achievement/launch/insight\nâ€¢ Sensitivity: professional achievement vs personal struggle\nâ€¢ Author level: entry/mid/senior/executive\n\nAPPROVED VOCABULARY:\nâ€¢ General: Great, Nice, Superb, Solid, Kudos, Congrats, Respect, Well done, Well said, Thoughtful, Insightful, Timely, Useful, Practical, Inspiring, Powerful\nâ€¢ Tech: Robust, Scalable, Efficient, Reliable, Optimized, Seamless, Innovative, Smart\nâ€¢ Business: Strategic, Impactful, Smart move, Growth-focused, Value-driven, Customer-first\nâ€¢ Finance: Prudent, Sustainable, Sensible, Growth-ready, Wise\nâ€¢ Healthcare/Social: Compassionate, Healing, Caring, Patient-first, Meaningful\nâ€¢ Sensitive situations: Strength, Prayers, Courage, Hope, Support, Resilience\nâ€¢ Indian-English (sparingly): Excellent, Outstanding, Brilliant, Fantastic\n\nCONTEXT-SPECIFIC EXAMPLES:\nâ€¢ Product launch â†’ \"Exciting ðŸš€\" / \"Congrats\" / \"Well done\"\nâ€¢ Promotion/new job â†’ \"Congrats ðŸŽ‰\" / \"Well deserved\" / \"Excellent\"\nâ€¢ Thought leadership â†’ \"Insightful ðŸ’¡\" / \"Well said\" / \"Thoughtful\"\nâ€¢ Personal achievement â†’ \"Inspiring\" / \"Respect\" / \"Outstanding\"\nâ€¢ Company milestone â†’ \"Impressive\" / \"Great news\" / \"Solid\"\nâ€¢ Learning/education â†’ \"Valuable\" / \"Useful\" / \"Practical\"\nâ€¢ Sensitive news â†’ \"Strength ðŸ™\" / \"Support\" / \"Courage\"\n\nFINAL OUTPUT:\nIf ad/sponsored â†’ {\"skip\": true, \"reason\": \"advertisement\"}\nElse â†’ {\"comment\": \"your_word_here\"}`;\n    }\n    \n    const basePrompt = `You are a LinkedIn engagement expert. Write a natural, authentic comment (max 3 sentences, 20â€“50 words).\n\nSTRICT RULES:\nâ€¢ Add value, don't repeat obvious phrases\nâ€¢ Respond with intelligence, empathy, or curiosity\nâ€¢ Avoid over-explainingâ€”stay within 3 sentences\nâ€¢ Include emojis only if they genuinely enhance tone\nâ€¢ Make every word countâ€”no filler content\nâ€¢ Reference specific details from the post when possible\n`;\n    \n    const stylePrompts = {\n      professional: `Professional tone with business insights. Use industry terminology naturally. Focus on strategic value and professional growth implications.`,\n      casual: `Friendly, conversational tone while remaining professional. Be approachable and personable. Use warm, relatable language without being overly familiar.`,\n      insightful: `Thoughtful analysis with meaningful questions. Be intellectually engaging and encourage discussion. Show genuine curiosity about their perspective.`,\n      supportive: `Encouraging and supportive. Acknowledge achievements and build others up with specific positive reinforcement. Celebrate their success authentically.`\n    };\n\n    const guidelines = `\n\nQUALITY MARKERS:\nâ€¢ Authentic voice that matches the post's tone\nâ€¢ Specific rather than generic responses\nâ€¢ Professional yet human interaction\nâ€¢ Strategic emoji use (max 1-2 per comment)\nâ€¢ Conversation-starting potential\n\nAVOID:\nâ€¢ Generic phrases like \"Great post!\" or \"Thanks for sharing!\"\nâ€¢ Over-enthusiasm that seems artificial\nâ€¢ Controversial topics or strong opinions\nâ€¢ Self-promotional content`;\n\n    return basePrompt + (stylePrompts[commentStyle] || stylePrompts.professional) + guidelines;\n  }\n\n  getUserPrompt(commentStyle, postContent) {\n    if (commentStyle === 'oneword') {\n      return `Analyze this LinkedIn post and respond with exactly ONE or TWO words (+ optional emoji) that captures the right response:\n\n${postContent}\n\nOutput JSON:\n{ \"comment\": \"your_1_or_2_words\" }\nor\n{ \"comment\": \"your_words ðŸŽ‰\" }`;\n    }\n\n    if (commentStyle === 'adaptive') {\n      return `Analyze this LinkedIn post deeply and generate a short, precise adaptive comment.\nConstraints: Max 2 sentences (~25 words). Context-aware, natural, and specific to the post type (career milestone, thought leadership, personal story, business update, or question).\nNever generic, never more than 2 sentences.\n\n${postContent}\n\nOutput JSON:\n{ \"comment\": \"your_adaptive_comment\" }`;\n    }\n\n    const styleDescriptions = {\n      'professional': 'Professional',\n      'casual': 'Casual',\n      'insightful': 'Insightful', \n      'supportive': 'Supportive'\n    };\n\n    const styleDesc = styleDescriptions[commentStyle] || 'Professional';\n    return `Please generate a ${styleDesc} LinkedIn comment.\nConstraints: Max 3 sentences, 20â€“50 words, authentic and engaging.\n\n${postContent}\n\nOutput JSON:\n{ \"comment\": \"your_comment_here\" }`;\n  }\n}\n\n// Initialize background service\nnew BackgroundService();\n","size_bytes":11091},"config.js":{"content":"// LinkedIn AI Engagement Bot - Configuration\n\nconst CONFIG = {\n  // Timing delays to appear more human-like (in milliseconds)\n  DELAYS: {\n    SCROLL: 1000,        // Delay after scrolling to post\n    CLICK: 500,          // Delay after clicking comment button\n    FOCUS: 300,          // Delay after focusing comment editor\n    TYPE: 1000,          // Delay after typing comment\n    SUBMIT: 1000,        // Delay after submitting comment\n    BETWEEN_POSTS: 3000  // Delay between processing posts\n  },\n\n  // LinkedIn selectors (may need updates if LinkedIn changes their DOM)\n  SELECTORS: {\n    FEED_POSTS: '.feed-shared-update-v2',\n    POST_CONTENT: [\n      '.feed-shared-text__text-view span[dir=\"ltr\"]',\n      '.feed-shared-text span[dir=\"ltr\"]',\n      '.feed-shared-update-v2__description span'\n    ],\n    COMMENT_BUTTON: [\n      '[aria-label*=\"omment\"]',\n      'button[data-control-name*=\"comment\"]',\n      '.social-actions-button:nth-child(2)'\n    ],\n    COMMENT_EDITOR: '.comments-comment-texteditor .ql-editor',\n    SUBMIT_BUTTON: '.comments-comment-texteditor .comments-comment-texteditor__submit-button:not([disabled])',\n    AUTHOR: [\n      '.feed-shared-actor__title a',\n      '.update-components-actor__title a'\n    ],\n    COMMENTS_SECTION: [\n      '.comments-comments-list',\n      '.social-details-social-comments'\n    ]\n  },\n\n  // Default settings\n  DEFAULTS: {\n    MAX_POSTS: 10,\n    MAX_LIKES: 15,\n    MAX_COMMENTS: 5,\n    COMMENT_STYLE: 'professional',\n    COMMENT_MIN_LENGTH: 20,\n    COMMENT_MAX_LENGTH: 80,\n    DELAY_MIN: 2,\n    DELAY_MAX: 8,\n    ENABLE_LIKES: true,\n    ENABLE_COMMENTS: true\n  },\n\n  // Error messages\n  ERRORS: {\n    NO_API_KEY: 'OpenAI API key is required',\n    INVALID_API_KEY: 'Invalid OpenAI API key format',\n    NOT_LINKEDIN: 'This extension only works on LinkedIn',\n    NO_POSTS_FOUND: 'No posts found in the current feed',\n    COMMENT_FAILED: 'Failed to post comment',\n    RATE_LIMITED: 'Rate limited by LinkedIn or OpenAI'\n  }\n};\n\n// Export config for other scripts\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = CONFIG;\n}\n","size_bytes":2096},"content.js":{"content":"// LinkedIn AI Engagement Bot - Content Script\n\nclass LinkedInBot {\n  constructor() {\n    this.isRunning = false;\n    this.config = {};\n    this.stats = {\n      postsFound: 0,\n      postsLiked: 0,\n      commentsPosted: 0,\n      errors: 0\n    };\n    this.processedPosts = new Set();\n    this.setupMessageListener();\n    \n    // Wait for page to be fully loaded\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => this.initialize());\n    } else {\n      this.initialize();\n    }\n  }\n\n  initialize() {\n    this.log('LinkedIn AI Bot initialized');\n  }\n\n  setupMessageListener() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      console.log('[LinkedIn Bot] Received message:', message.type);\n      \n      try {\n        switch (message.type) {\n          case 'START_BOT':\n            this.startBot(message.config);\n            sendResponse({ success: true, message: 'Bot started successfully' });\n            break;\n          case 'STOP_BOT':\n            this.stopBot();\n            sendResponse({ success: true, message: 'Bot stopped successfully' });\n            break;\n          case 'PING':\n            // Health check message\n            sendResponse({ success: true, message: 'Content script is active' });\n            break;\n          default:\n            sendResponse({ success: false, message: `Unknown message type: ${message.type}` });\n        }\n      } catch (error) {\n        console.error('[LinkedIn Bot] Message handler error:', error);\n        sendResponse({ success: false, message: error.message });\n      }\n      \n      return true; // Keep message channel open for async operations\n    });\n  }\n\n  async startBot(config) {\n    if (this.isRunning) {\n      this.log('Bot is already running', 'error');\n      return;\n    }\n\n    this.config = config;\n    this.isRunning = true;\n    this.processedPosts.clear();\n    \n    this.log('Starting LinkedIn engagement bot...');\n    this.updateStatus('Running - Scanning for posts...');\n    \n    try {\n      await this.processFeedPosts();\n    } catch (error) {\n      this.log('Bot execution error: ' + error.message, 'error');\n      this.updateStats({ errors: this.stats.errors + 1 });\n    } finally {\n      this.stopBot();\n    }\n  }\n\n  stopBot() {\n    this.isRunning = false;\n    this.log('Bot stopped');\n    this.sendMessage({ type: 'BOT_STOPPED' });\n  }\n\n  async processFeedPosts() {\n    this.log('Starting sequential post-by-post processing...');\n    this.updateStatus('Processing posts one by one...');\n    \n    let likesCount = 0;\n    let commentsCount = 0;\n    let singleWordCommentCount = 0;\n    let explanatoryCommentCount = 0;\n    let postsExamined = 0;\n    let skippedCount = 0;\n    \n    // Track targets\n    const targetLikes = this.config.maxLikes || 0;\n    const targetComments = this.config.maxComments || 0;\n    const targetSingleWord = this.config.singleWordComments || 0;\n    const targetExplanatory = this.config.explanatoryComments || 0;\n    \n    this.log(`Targets: ${targetLikes} likes, ${targetComments} comments (${targetSingleWord} single-word + ${targetExplanatory} explanatory)`);\n    \n    // Start from the current position and process posts as we encounter them\n    let scrollAttempts = 0;\n    const maxScrollAttempts = 10; // Allow more scrolling for sequential processing\n    \n    while (this.isRunning && scrollAttempts < maxScrollAttempts) {\n      // Find posts currently visible on screen\n      const visiblePosts = this.findCurrentlyVisiblePosts();\n      \n      if (visiblePosts.length === 0) {\n        this.log('No visible posts found, scrolling to load more...');\n        await this.scrollToLoadMorePosts();\n        scrollAttempts++;\n        continue;\n      }\n      \n      let processedInThisBatch = false;\n      \n      // Process each visible post\n      for (const postElement of visiblePosts) {\n        if (!this.isRunning) break;\n        \n        // Check if we've reached all our targets\n        if (likesCount >= targetLikes && commentsCount >= targetComments) {\n          this.log('All targets reached!');\n          this.isRunning = false;\n          break;\n        }\n        \n        try {\n          // Extract post data\n          const postData = this.extractPostData(postElement);\n          \n          if (!postData || this.processedPosts.has(postData.id)) {\n            continue; // Skip if we can't extract data or already processed\n          }\n          \n          postsExamined++;\n          this.processedPosts.add(postData.id);\n          \n          this.log(`Examining post ${postsExamined} by ${postData.author}`);\n          \n          // Determine what actions to take randomly but respecting quotas\n          const actions = this.determineRandomActions(postData, {\n            likesCount,\n            commentsCount,\n            singleWordCommentCount,\n            explanatoryCommentCount,\n            targetLikes,\n            targetComments,\n            targetSingleWord,\n            targetExplanatory\n          });\n          \n          if (actions.length === 0) {\n            this.log(`Skipping post by ${postData.author} - already engaged or no quota remaining`);\n            skippedCount++;\n            continue;\n          }\n          \n          // Process the post with determined actions\n          const result = await this.processPostSequentially(postData, actions);\n          \n          if (result.liked) {\n            likesCount++;\n            this.log(`âœ“ Liked post ${likesCount}/${targetLikes} by ${postData.author}`);\n          }\n          \n          if (result.commented) {\n            commentsCount++;\n            if (result.commentType === 'singleword') {\n              singleWordCommentCount++;\n              this.log(`âœ“ Posted single-word comment ${singleWordCommentCount}/${targetSingleWord} on post by ${postData.author}`);\n            } else {\n              explanatoryCommentCount++;\n              this.log(`âœ“ Posted explanatory comment ${explanatoryCommentCount}/${targetExplanatory} on post by ${postData.author}`);\n            }\n          }\n          \n          processedInThisBatch = true;\n          \n          // Update stats\n          this.updateStats({ \n            postsFound: postsExamined,\n            postsLiked: likesCount,\n            commentsPosted: commentsCount\n          });\n          \n          // Human-like delay between actions\n          const delay = this.getRandomDelay();\n          this.log(`Waiting ${delay}s before next post...`);\n          await this.delay(delay * 1000);\n          \n        } catch (error) {\n          if (error.message.includes('Skipping advertisement') || error.message.includes('already')) {\n            this.log(`${error.message}`, 'info');\n            skippedCount++;\n          } else {\n            this.log(`Error processing post: ${error.message}`, 'error');\n            this.updateStats({ errors: this.stats.errors + 1 });\n          }\n        }\n      }\n      \n      // If we didn't process any posts in this batch, scroll down\n      if (!processedInThisBatch) {\n        this.log('No posts processed in this batch, scrolling to find more...');\n        await this.scrollToLoadMorePosts();\n        scrollAttempts++;\n      } else {\n        scrollAttempts = 0; // Reset scroll attempts if we found posts to process\n      }\n    }\n    \n    this.log(`Sequential processing completed!`);\n    this.log(`Final results: ${postsExamined} posts examined, ${skippedCount} skipped`);\n    this.log(`Actions taken: ${likesCount} likes, ${commentsCount} comments (${singleWordCommentCount} single-word + ${explanatoryCommentCount} explanatory)`);\n    this.updateStatus(`Completed - ${likesCount} likes, ${commentsCount} comments, ${skippedCount} skipped`);\n  }\n\n  // Legacy function - no longer used since we switched to sequential processing\n\n  extractPostData(postElement) {\n    // Debug: Log post element structure\n    this.log(`Analyzing post element with classes: ${postElement.className}`);\n    \n    // Check for sponsored/promoted content and skip\n    const isAd = this.isAdvertisement(postElement);\n    if (isAd) {\n      this.log(`Detected sponsored content, skipping post`, 'info');\n      throw new Error('Skipping advertisement/sponsored post');\n    }\n    \n    this.log(`Processing regular post for content extraction`, 'info');\n    \n    // Check if already engaged with this post\n    const alreadyEngaged = this.isAlreadyEngaged(postElement);\n    \n    // We will handle individual action skipping later, don't skip entire post here\n    // Just store the engagement status for later use\n    \n    // Find the post content using multiple selectors for LinkedIn's dynamic structure\n    const contentElement = postElement.querySelector('.feed-shared-text__text-view .break-words') ||\n                          postElement.querySelector('.feed-shared-text .break-words') ||\n                          postElement.querySelector('.feed-shared-update-v2__description .break-words') ||\n                          postElement.querySelector('.feed-shared-text__text-view span') ||\n                          postElement.querySelector('.feed-shared-text span') ||\n                          postElement.querySelector('.update-components-text span') ||\n                          postElement.querySelector('[data-test-id=\"main-feed-activity-card\"] .break-words') ||\n                          postElement.querySelector('.feed-shared-update-v2__description span') ||\n                          postElement.querySelector('.feed-shared-text__text-view') ||\n                          postElement.querySelector('.feed-shared-text') ||\n                          postElement.querySelector('.update-components-text');\n    \n    if (!contentElement) {\n      // Debug: Show what elements we can find\n      this.log(`No content element found with standard selectors`);\n      \n      const textElements = postElement.querySelectorAll('*');\n      const textElementsWithContent = Array.from(textElements).filter(el => \n        el.textContent && el.textContent.trim().length > 20 && \n        !el.querySelector('*') // Only leaf nodes\n      );\n      \n      this.log(`Found ${textElementsWithContent.length} potential text elements in fallback`);\n      \n      // Log first few text elements for debugging\n      textElementsWithContent.slice(0, 3).forEach((el, i) => {\n        this.log(`Text element ${i + 1}: \"${el.textContent.trim().substring(0, 50)}...\"`);\n      });\n      \n      if (textElementsWithContent.length > 0) {\n        this.log(`Using fallback method with first text element`);\n        return this.createPostDataFromFallback(postElement, textElementsWithContent[0]);\n      }\n      \n      throw new Error('Could not find post content - no text elements found');\n    }\n\n    // Get post ID (using data attributes or generating one)\n    let postId = postElement.getAttribute('data-urn') || \n                 postElement.getAttribute('data-id') ||\n                 postElement.querySelector('[data-urn]')?.getAttribute('data-urn');\n    \n    if (!postId) {\n      // Generate a unique ID based on content and position\n      postId = this.generatePostId(contentElement.textContent, postElement);\n    }\n\n    // Check if we can comment (look for comment button)\n    const commentButton = this.findCommentButton(postElement);\n    this.log(`Comment button found: ${!!commentButton}`);\n\n    if (!commentButton || commentButton.disabled) {\n      this.log(`Cannot comment - button missing or disabled`);\n      throw new Error('Cannot comment on this post');\n    }\n\n    // Extract author info\n    const authorElement = postElement.querySelector('.feed-shared-actor__title a') ||\n                         postElement.querySelector('.update-components-actor__title a') ||\n                         postElement.querySelector('.feed-shared-actor__name a') ||\n                         postElement.querySelector('.update-components-actor__name a');\n    \n    const authorName = authorElement ? authorElement.textContent.trim() : 'Unknown';\n\n    // Get engagement status\n    const engagementStatus = this.isAlreadyEngaged(postElement);\n\n    return {\n      id: postId,\n      content: contentElement.textContent.trim(),\n      author: authorName,\n      element: postElement,\n      commentButton: commentButton,\n      alreadyLiked: engagementStatus.liked,\n      alreadyCommented: engagementStatus.commented\n    };\n  }\n\n  createPostDataFromFallback(postElement, contentElement) {\n    // Get post ID\n    let postId = postElement.getAttribute('data-urn') || \n                 postElement.getAttribute('data-id') ||\n                 postElement.querySelector('[data-urn]')?.getAttribute('data-urn');\n    \n    if (!postId) {\n      postId = this.generatePostId(contentElement.textContent, postElement);\n    }\n\n    // Find comment button\n    const commentButton = this.findCommentButton(postElement);\n    if (!commentButton || commentButton.disabled) {\n      throw new Error('Cannot comment on this post');\n    }\n\n    // Extract author info\n    const authorElement = postElement.querySelector('.feed-shared-actor__title a') ||\n                         postElement.querySelector('.update-components-actor__title a') ||\n                         postElement.querySelector('.feed-shared-actor__name a') ||\n                         postElement.querySelector('.update-components-actor__name a');\n    \n    const authorName = authorElement ? authorElement.textContent.trim() : 'Unknown';\n\n    // Get engagement status\n    const engagementStatus = this.isAlreadyEngaged(postElement);\n\n    return {\n      id: postId,\n      content: contentElement.textContent.trim(),\n      author: authorName,\n      element: postElement,\n      commentButton: commentButton,\n      alreadyLiked: engagementStatus.liked,\n      alreadyCommented: engagementStatus.commented\n    };\n  }\n\n  isAdvertisement(postElement) {\n    // Very specific checks for actual sponsored/promoted content only\n    \n    // Check for explicit promoted post data attributes (most reliable)\n    const hasPromotedData = postElement.querySelector('[data-promoted-post=\"true\"]') ||\n                           postElement.hasAttribute('data-promoted') ||\n                           postElement.classList.contains('feed-shared-update-v2--promoted');\n    \n    if (hasPromotedData) {\n      return true;\n    }\n    \n    // Check for \"Promoted\" or \"Sponsored\" text in very specific locations\n    // Look in subtitle/secondary text areas where LinkedIn puts promotion labels\n    const promotionIndicators = postElement.querySelectorAll(\n      '.feed-shared-actor__sub-description, .feed-shared-actor__supplementary-actor-info, .update-components-actor__description'\n    );\n    \n    for (const indicator of promotionIndicators) {\n      const text = indicator.textContent.trim().toLowerCase();\n      // Must be exact matches for \"promoted\" or \"sponsored\" as standalone words\n      if (text === 'promoted' || text === 'sponsored' || \n          text.startsWith('promoted ') || text.startsWith('sponsored ')) {\n        return true;\n      }\n    }\n    \n    // Check for sponsored content in aria-labels (very specific)\n    const sponsoredAriaLabels = postElement.querySelector('[aria-label*=\"Sponsored\"][aria-label*=\"post\"]') ||\n                               postElement.querySelector('[aria-label*=\"Promoted\"][aria-label*=\"post\"]');\n    \n    if (sponsoredAriaLabels) {\n      return true;\n    }\n    \n    // If none of the specific indicators are found, it's not an ad\n    return false;\n  }\n\n  isAlreadyEngaged(postElement) {\n    // Check if WE already liked this post (liked button will have active/pressed state)\n    const likeButton = postElement.querySelector('[data-control-name=\"like\"]') ||\n                      postElement.querySelector('button[aria-label*=\"like\"]') ||\n                      postElement.querySelector('.react-button__trigger');\n    \n    const alreadyLiked = likeButton && (\n      likeButton.classList.contains('react-button__trigger--active') ||\n      likeButton.classList.contains('reactions-react-button--active') ||\n      likeButton.getAttribute('aria-pressed') === 'true' ||\n      likeButton.querySelector('.reaction-button--active')\n    );\n    \n    // Check if WE already commented - look for our own comments specifically\n    // Get the current user's name/profile info from LinkedIn's header or navigation\n    const currentUserName = this.getCurrentUserName();\n    let alreadyCommented = false;\n    \n    if (currentUserName) {\n      // Look for comment items that belong to the current user\n      const commentItems = postElement.querySelectorAll('.comments-comment-item');\n      \n      for (const comment of commentItems) {\n        const commentAuthor = comment.querySelector('.comments-comment-item__commenter-identity .hoverable-link-text, .comments-comment-item__commenter .hoverable-link-text');\n        if (commentAuthor && commentAuthor.textContent.trim().toLowerCase().includes(currentUserName.toLowerCase())) {\n          alreadyCommented = true;\n          break;\n        }\n      }\n    } else {\n      // Fallback: be more conservative - if there are any comments, assume we might have commented\n      // This is less accurate but safer than the old logic\n      alreadyCommented = false; // Don't skip based on others' comments\n    }\n    \n    return {\n      liked: !!alreadyLiked,\n      commented: alreadyCommented\n    };\n  }\n  \n  getCurrentUserName() {\n    // Try to get current user name from LinkedIn navigation/header\n    const userNameSelectors = [\n      '.global-nav__me-photo + span', // User name next to profile photo\n      '.global-nav__me-content .t-16--open', // User name in navigation\n      '.global-nav__primary-link-me-menu-trigger span:not(.visually-hidden)', // Me menu trigger\n      '[data-control-name=\"identity_welcome_message\"] .t-16', // Welcome message\n      '.global-nav__me .artdeco-button__text' // Me button text\n    ];\n    \n    for (const selector of userNameSelectors) {\n      const element = document.querySelector(selector);\n      if (element && element.textContent && element.textContent.trim().length > 0) {\n        const userName = element.textContent.trim();\n        // Extract first and last name, ignore things like \"(You)\" or other additions\n        const cleanName = userName.replace(/\\s*\\([^)]*\\)\\s*/g, '').trim();\n        if (cleanName.length > 0) {\n          this.log(`Detected current user: ${cleanName}`);\n          return cleanName;\n        }\n      }\n    }\n    \n    // Fallback: try to get from URL or other sources\n    const profileElements = document.querySelectorAll('[data-control-name=\"nav.settings_and_privacy\"], .global-nav__me');\n    for (const element of profileElements) {\n      const title = element.title || element.getAttribute('aria-label') || '';\n      if (title.includes('View profile') || title.includes('Account for')) {\n        const nameMatch = title.match(/(?:View profile for|Account for)\\s+([^,\\n]+)/);\n        if (nameMatch && nameMatch[1]) {\n          const userName = nameMatch[1].trim();\n          this.log(`Detected current user from title: ${userName}`);\n          return userName;\n        }\n      }\n    }\n    \n    this.log('Could not detect current user name - will be conservative about comment checking');\n    return null;\n  }\n\n  findCommentButton(postElement) {\n    // Try multiple selectors for comment buttons\n    return postElement.querySelector('[aria-label*=\"Comment\"]') ||\n           postElement.querySelector('[aria-label*=\"comment\"]') ||\n           postElement.querySelector('button[data-control-name*=\"comment\"]') ||\n           postElement.querySelector('.social-actions-button[aria-label*=\"Comment\"]') ||\n           postElement.querySelector('.feed-shared-social-action-bar button[aria-label*=\"Comment\"]') ||\n           postElement.querySelector('.social-counts-reactions__comment-button') ||\n           postElement.querySelector('.feed-shared-social-action-bar .artdeco-button:nth-child(2)') ||\n           postElement.querySelector('.social-actions-button:nth-child(2)');\n  }\n\n  findLikeButton(postElement) {\n    // Try multiple selectors for like buttons\n    return postElement.querySelector('[aria-label*=\"Like\"]') ||\n           postElement.querySelector('[aria-label*=\"like\"]') ||\n           postElement.querySelector('button[data-control-name*=\"like\"]') ||\n           postElement.querySelector('.social-actions-button[aria-label*=\"Like\"]') ||\n           postElement.querySelector('.feed-shared-social-action-bar button[aria-label*=\"Like\"]') ||\n           postElement.querySelector('.reactions-react-button') ||\n           postElement.querySelector('.feed-shared-social-action-bar .artdeco-button:first-child') ||\n           postElement.querySelector('.social-actions-button:first-child');\n  }\n\n  async likePost(postData) {\n    try {\n      const likeButton = this.findLikeButton(postData.element);\n      \n      if (!likeButton) {\n        throw new Error('Like button not found');\n      }\n\n      // Check if already liked\n      const isLiked = likeButton.getAttribute('aria-pressed') === 'true' ||\n                     likeButton.classList.contains('artdeco-button--primary') ||\n                     likeButton.querySelector('[data-test-icon=\"thumbs-up-filled-icon\"]') ||\n                     likeButton.textContent.toLowerCase().includes('liked');\n\n      if (isLiked) {\n        this.log(`Post by ${postData.author} already liked, skipping`);\n        return;\n      }\n\n      // Click the like button\n      likeButton.click();\n      await this.delay(this.getRandomDelay(0.3, 1) * 1000);\n\n      // Verify the like was successful\n      const nowLiked = likeButton.getAttribute('aria-pressed') === 'true' ||\n                      likeButton.classList.contains('artdeco-button--primary') ||\n                      likeButton.querySelector('[data-test-icon=\"thumbs-up-filled-icon\"]');\n\n      if (!nowLiked) {\n        this.log(`Warning: Could not verify like on post by ${postData.author}`);\n      }\n\n    } catch (error) {\n      throw new Error(`Failed to like post: ${error.message}`);\n    }\n  }\n\n  getRandomDelay(min = null, max = null) {\n    // Use config delays if no specific range provided\n    const minDelay = min !== null ? min : this.config.delayMin || 2;\n    const maxDelay = max !== null ? max : this.config.delayMax || 8;\n    \n    // Generate random delay between min and max\n    return Math.random() * (maxDelay - minDelay) + minDelay;\n  }\n\n  generatePostId(content, element) {\n    // Create a simple hash from content and element position\n    const text = content.substring(0, 100);\n    const position = Array.from(element.parentNode.children).indexOf(element);\n    return btoa(text + position).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);\n  }\n\n  async processPost(postData, actions) {\n    this.log(`Processing post by ${postData.author} (${actions.join(', ')})...`);\n    this.updateStatus(`Processing post by ${postData.author}`);\n\n    const result = { liked: false, commented: false };\n\n    // Scroll to post\n    postData.element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    await this.delay(this.getRandomDelay(1, 2) * 1000);\n\n    // Process actions in random order to appear more human\n    const shuffledActions = [...actions].sort(() => Math.random() - 0.5);\n\n    for (const action of shuffledActions) {\n      if (!this.isRunning) break;\n\n      try {\n        if (action === 'like' && !postData.alreadyLiked) {\n          await this.likePost(postData);\n          result.liked = true;\n          this.updateStats({ postsLiked: this.stats.postsLiked + 1 });\n          this.log(`âœ“ Liked post by ${postData.author}`, 'success');\n          \n          // Random delay between actions\n          if (shuffledActions.length > 1) {\n            await this.delay(this.getRandomDelay(0.5, 2) * 1000);\n          }\n        } else if (action === 'like' && postData.alreadyLiked) {\n          this.log(`â­ï¸ Already liked post by ${postData.author}`, 'info');\n        }\n\n        if (action === 'comment' && postData.alreadyCommented) {\n          this.log(`â­ï¸ Already commented on post by ${postData.author}`, 'info');\n        }\n\n        if (action === 'comment' && !postData.alreadyCommented) {\n          this.log(`âœ… Starting comment generation for ${postData.author} (alreadyCommented: ${postData.alreadyCommented})`, 'info');\n          this.log(`Generating ${this.config.commentStyle} comment for post by ${postData.author}...`, 'info');\n          const commentResult = await this.generateComment(postData.content);\n          \n          if (commentResult && commentResult.skip) {\n            this.log(`â­ï¸ Skipped post by ${postData.author}: ${commentResult.reason}`, 'info');\n          } else if (commentResult && commentResult.comment) {\n            this.log(`Generated comment: \"${commentResult.comment}\"`, 'info');\n            await this.postComment(postData, commentResult.comment);\n            result.commented = true;\n            this.updateStats({ commentsPosted: this.stats.commentsPosted + 1 });\n            this.log(`âœ“ Commented on post by ${postData.author}: \"${commentResult.comment}\"`, 'success');\n          } else {\n            this.log(`Failed to generate comment for post by ${postData.author} - no comment returned`, 'error');\n            this.updateStats({ errors: this.stats.errors + 1 });\n          }\n        }\n      } catch (error) {\n        this.log(`Error with ${action} on post by ${postData.author}: ${error.message}`, 'error');\n      }\n    }\n\n    return result;\n  }\n\n  async generateComment(postContent) {\n    return new Promise((resolve, reject) => {\n      chrome.runtime.sendMessage({\n        type: 'GENERATE_COMMENT',\n        postContent: postContent,\n        commentStyle: this.config.commentStyle,\n        apiKey: this.config.apiKey\n      }, (response) => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message));\n          return;\n        }\n\n        if (response.success) {\n          resolve(response.result);\n        } else {\n          reject(new Error(response.error || 'Failed to generate comment'));\n        }\n      });\n    });\n  }\n\n  async postComment(postData, comment) {\n    try {\n      // Scroll post into view\n      postData.element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      await this.delay(CONFIG.DELAYS.SCROLL);\n\n      // Click comment button\n      postData.commentButton.click();\n      await this.delay(CONFIG.DELAYS.CLICK);\n\n      // Wait for comment editor to appear\n      const commentEditor = await this.waitForElement(\n        '.comments-comment-texteditor .ql-editor, .comments-comment-texteditor div[contenteditable=\"true\"], .comments-comment-box__form div[contenteditable=\"true\"], .ql-editor[contenteditable=\"true\"]',\n        3000,\n        postData.element\n      );\n\n      if (!commentEditor) {\n        throw new Error('Comment editor not found');\n      }\n\n      // Focus and type comment\n      commentEditor.focus();\n      await this.delay(CONFIG.DELAYS.FOCUS);\n\n      // Clear any existing content\n      commentEditor.innerHTML = '';\n      \n      // Type the comment\n      await this.typeText(commentEditor, comment);\n      await this.delay(CONFIG.DELAYS.TYPE);\n\n      // Find and click submit button\n      const submitButton = await this.waitForElement(\n        '.comments-comment-texteditor .comments-comment-texteditor__submit-button:not([disabled]), .comments-comment-box__submit-button:not([disabled]), .comments-comment-texteditor button[type=\"submit\"]:not([disabled]), .artdeco-button--primary:not([disabled])',\n        2000,\n        postData.element\n      );\n\n      if (!submitButton) {\n        throw new Error('Submit button not found or disabled');\n      }\n\n      submitButton.click();\n      await this.delay(CONFIG.DELAYS.SUBMIT);\n\n      // Verify comment was posted\n      await this.verifyCommentPosted(postData.element, comment);\n\n    } catch (error) {\n      throw new Error(`Failed to post comment: ${error.message}`);\n    }\n  }\n\n  async verifyCommentPosted(postElement, expectedComment) {\n    // Wait a bit for the comment to appear\n    await this.delay(2000);\n    \n    // Look for the comment in the comments section\n    const commentsSection = postElement.querySelector('.comments-comments-list') ||\n                           postElement.querySelector('.social-details-social-comments');\n    \n    if (commentsSection) {\n      const comments = commentsSection.querySelectorAll('.comments-comment-item__main-content');\n      \n      for (const commentEl of comments) {\n        const commentText = commentEl.textContent.trim();\n        if (commentText.includes(expectedComment.substring(0, 20))) {\n          return true; // Comment found\n        }\n      }\n    }\n    \n    // If we can't verify, assume it worked (LinkedIn sometimes delays showing comments)\n    this.log('Could not verify comment posting, but assuming success');\n    return true;\n  }\n\n  async typeText(element, text) {\n    // Clear existing content first\n    element.focus();\n    \n    // Use different methods based on editor type\n    if (element.getAttribute('contenteditable') === 'true') {\n      // For contenteditable elements (LinkedIn's rich text editor)\n      element.innerHTML = '';\n      \n      // Insert text and trigger events\n      element.textContent = text;\n      \n      // Trigger input events that LinkedIn expects\n      element.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n      element.dispatchEvent(new Event('keyup', { bubbles: true, cancelable: true }));\n      element.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));\n      \n      // Trigger composition events for better compatibility\n      element.dispatchEvent(new CompositionEvent('compositionstart', { bubbles: true }));\n      element.dispatchEvent(new CompositionEvent('compositionend', { bubbles: true, data: text }));\n      \n    } else {\n      // For regular input elements\n      element.value = text;\n      element.dispatchEvent(new Event('input', { bubbles: true }));\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n    \n    // Final focus and blur to ensure state is correct\n    await this.delay(100);\n    element.blur();\n    await this.delay(100);\n    element.focus();\n  }\n\n  async waitForElement(selector, timeout = 5000, parent = document) {\n    return new Promise((resolve) => {\n      const element = parent.querySelector(selector);\n      if (element) {\n        resolve(element);\n        return;\n      }\n\n      const observer = new MutationObserver(() => {\n        const element = parent.querySelector(selector);\n        if (element) {\n          observer.disconnect();\n          resolve(element);\n        }\n      });\n\n      observer.observe(parent, {\n        childList: true,\n        subtree: true\n      });\n\n      setTimeout(() => {\n        observer.disconnect();\n        resolve(null);\n      }, timeout);\n    });\n  }\n\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  updateStatus(status) {\n    this.sendMessage({ type: 'STATUS_UPDATE', status });\n  }\n\n  updateStats(newStats) {\n    this.stats = { ...this.stats, ...newStats };\n    this.sendMessage({ type: 'STATS_UPDATE', stats: this.stats });\n  }\n\n  log(message, level = 'info') {\n    console.log(`[LinkedIn Bot] ${message}`);\n    this.sendMessage({\n      type: 'LOG_MESSAGE',\n      message: message,\n      level: level\n    });\n  }\n\n  sendMessage(message) {\n    try {\n      chrome.runtime.sendMessage(message);\n    } catch (error) {\n      console.error('Failed to send message:', error);\n    }\n  }\n  \n  findCurrentlyVisiblePosts() {\n    // Find posts currently visible in viewport or near it\n    const postElements = document.querySelectorAll('.feed-shared-update-v2, [data-test-id=\"main-feed-activity-card\"], .feed-shared-update-v2__container');\n    const visiblePosts = [];\n    \n    for (const postElement of postElements) {\n      // Check if post is in or near viewport\n      const rect = postElement.getBoundingClientRect();\n      const isVisible = rect.top < window.innerHeight + 200 && rect.bottom > -200; // Include posts 200px outside viewport\n      \n      if (isVisible && !this.processedPosts.has(this.generatePostId(postElement))) {\n        visiblePosts.push(postElement);\n      }\n    }\n    \n    this.log(`Found ${visiblePosts.length} visible posts to examine`);\n    return visiblePosts;\n  }\n  \n  async scrollToLoadMorePosts() {\n    // Scroll down smoothly to load more posts\n    const scrollAmount = 300 + Math.random() * 400; // Random scroll between 300-700px\n    window.scrollBy({ \n      top: scrollAmount, \n      behavior: 'smooth' \n    });\n    \n    // Wait for content to load\n    const pauseTime = 1000 + Math.random() * 1000; // 1-2 seconds\n    await this.delay(pauseTime);\n  }\n  \n  generatePostId(postElement) {\n    // Generate a consistent ID for a post element\n    const authorElement = postElement.querySelector('.feed-shared-actor__title a, .update-components-actor__title a');\n    const contentElement = postElement.querySelector('.feed-shared-text__text-view, .feed-shared-text, .update-components-text');\n    \n    const author = authorElement ? authorElement.textContent.trim() : 'unknown';\n    const content = contentElement ? contentElement.textContent.trim().substring(0, 50) : 'no-content';\n    \n    return `${author}_${content}`.replace(/[^a-zA-Z0-9]/g, '_');\n  }\n  \n  determineRandomActions(postData, quotaStatus) {\n    const actions = [];\n    \n    // Check if we can like this post\n    const canLike = !postData.alreadyLiked && \n                   quotaStatus.likesCount < quotaStatus.targetLikes;\n    \n    // Check if we can comment on this post\n    const canComment = !postData.alreadyCommented && \n                      quotaStatus.commentsCount < quotaStatus.targetComments;\n    \n    if (!canLike && !canComment) {\n      return actions; // No actions possible\n    }\n    \n    // Random decision making - more natural distribution\n    const likeChance = 0.6; // 60% chance to like if possible\n    const commentChance = 0.4; // 40% chance to comment if possible\n    \n    // Sometimes do both, sometimes just one\n    const shouldLike = canLike && Math.random() < likeChance;\n    const shouldComment = canComment && Math.random() < commentChance;\n    \n    if (shouldLike) {\n      actions.push('like');\n    }\n    \n    if (shouldComment) {\n      // Determine comment type based on remaining quota\n      const singleWordRemaining = quotaStatus.targetSingleWord - quotaStatus.singleWordCommentCount;\n      const explanatoryRemaining = quotaStatus.targetExplanatory - quotaStatus.explanatoryCommentCount;\n      \n      if (singleWordRemaining > 0 && explanatoryRemaining > 0) {\n        // Both types available, choose based on ratio (70/30 preference)\n        const usesSingleWord = Math.random() < 0.7;\n        actions.push(usesSingleWord ? 'comment_singleword' : 'comment_explanatory');\n      } else if (singleWordRemaining > 0) {\n        actions.push('comment_singleword');\n      } else if (explanatoryRemaining > 0) {\n        actions.push('comment_explanatory');\n      }\n    }\n    \n    return actions;\n  }\n  \n  async processPostSequentially(postData, actions) {\n    this.log(`Processing post by ${postData.author} with actions: ${actions.join(', ')}...`);\n    this.updateStatus(`Processing post by ${postData.author}`);\n\n    const result = { liked: false, commented: false, commentType: null };\n\n    // Scroll to post\n    postData.element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    await this.delay(this.getRandomDelay(1, 2) * 1000);\n\n    // Process actions in random order for more natural behavior\n    const shuffledActions = [...actions].sort(() => Math.random() - 0.5);\n\n    for (const action of shuffledActions) {\n      if (!this.isRunning) break;\n\n      try {\n        if (action === 'like') {\n          await this.likePost(postData);\n          result.liked = true;\n          this.log(`âœ“ Liked post by ${postData.author}`, 'success');\n          \n          // Random delay between actions\n          if (shuffledActions.length > 1) {\n            await this.delay(this.getRandomDelay(0.5, 2) * 1000);\n          }\n        }\n\n        if (action.startsWith('comment_')) {\n          const commentType = action.split('_')[1]; // 'singleword' or 'explanatory'\n          this.log(`Generating ${commentType} comment for post by ${postData.author}...`, 'info');\n          \n          const commentResult = await this.generateCommentByType(postData.content, commentType);\n          \n          if (commentResult && commentResult.skip) {\n            this.log(`â­ï¸ Skipped post by ${postData.author}: ${commentResult.reason}`, 'info');\n          } else if (commentResult && commentResult.comment) {\n            this.log(`Generated ${commentType} comment: \"${commentResult.comment}\"`, 'info');\n            await this.postComment(postData, commentResult.comment);\n            result.commented = true;\n            result.commentType = commentType;\n            this.log(`âœ“ Commented on post by ${postData.author}: \"${commentResult.comment}\"`, 'success');\n          } else {\n            this.log(`Failed to generate ${commentType} comment for post by ${postData.author}`, 'error');\n            this.updateStats({ errors: this.stats.errors + 1 });\n          }\n        }\n      } catch (error) {\n        this.log(`Error with ${action} on post by ${postData.author}: ${error.message}`, 'error');\n      }\n    }\n\n    return result;\n  }\n  \n  async generateCommentByType(postContent, commentType) {\n    // Use appropriate comment style based on type\n    const commentStyle = commentType === 'singleword' ? 'oneword' : 'adaptive';\n    return await this.generateComment(postContent, commentStyle);\n  }\n  \n  async generateComment(postContent, commentStyle = 'adaptive') {\n    try {\n      this.log(`Generating ${commentStyle} comment...`, 'info');\n      \n      const response = await chrome.runtime.sendMessage({\n        type: 'GENERATE_COMMENT',\n        postContent: postContent,\n        commentStyle: commentStyle,\n        apiKey: this.config.apiKey\n      });\n      \n      if (response && response.success) {\n        return response.result;\n      } else {\n        throw new Error(response?.error || 'Failed to generate comment');\n      }\n    } catch (error) {\n      this.log(`Comment generation error: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n}\n\n// Initialize bot when script loads\nnew LinkedInBot();\n","size_bytes":38274},"popup.css":{"content":"body {\n  width: 380px;\n  min-height: 580px;\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n  color: #2d3748;\n}\n\n.container {\n  padding: 20px;\n  height: 100vh;\n  box-sizing: border-box;\n  overflow-y: auto;\n}\n\n.header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 24px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.header h2 {\n  margin: 0;\n  background: linear-gradient(135deg, #0077b5, #00a0dc);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n  font-size: 20px;\n  font-weight: 700;\n  display: flex;\n  align-items: center;\n}\n\n.header h2::before {\n  content: \"ðŸ¤–\";\n  margin-right: 8px;\n  font-size: 18px;\n}\n\n.status {\n  padding: 8px 16px;\n  border-radius: 20px;\n  font-size: 12px;\n  font-weight: 600;\n  background: rgba(231, 243, 248, 0.9);\n  color: #0077b5;\n  border: 1px solid rgba(0, 119, 181, 0.2);\n  backdrop-filter: blur(4px);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n  transition: all 0.3s ease;\n}\n\n.status.running {\n  background: linear-gradient(135deg, #48bb78, #38a169);\n  color: white;\n  box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);\n}\n\n.status.error {\n  background: linear-gradient(135deg, #f56565, #e53e3e);\n  color: white;\n  box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);\n}\n\n.config-section {\n  margin-bottom: 24px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.form-group {\n  margin-bottom: 20px;\n  position: relative;\n}\n\n.form-group label {\n  display: block;\n  margin-bottom: 8px;\n  font-weight: 600;\n  color: #4a5568;\n  font-size: 14px;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.form-group input,\n.form-group select {\n  width: 100%;\n  padding: 12px 16px;\n  border: 2px solid rgba(226, 232, 240, 0.8);\n  border-radius: 12px;\n  font-size: 14px;\n  box-sizing: border-box;\n  background: rgba(255, 255, 255, 0.9);\n  transition: all 0.3s ease;\n  font-family: inherit;\n}\n\n.form-group input:focus,\n.form-group select:focus {\n  outline: none;\n  border-color: #0077b5;\n  box-shadow: 0 0 0 3px rgba(0, 119, 181, 0.1);\n  background: white;\n  transform: translateY(-1px);\n}\n\n.form-group input:hover,\n.form-group select:hover {\n  border-color: rgba(0, 119, 181, 0.5);\n}\n\n.btn {\n  padding: 12px 24px;\n  border: none;\n  border-radius: 12px;\n  cursor: pointer;\n  font-size: 14px;\n  font-weight: 600;\n  transition: all 0.3s ease;\n  font-family: inherit;\n  position: relative;\n  overflow: hidden;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.btn::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: -100%;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);\n  transition: left 0.5s;\n}\n\n.btn:hover::before {\n  left: 100%;\n}\n\n.btn-primary {\n  background: linear-gradient(135deg, #0077b5, #00a0dc);\n  color: white;\n  width: 100%;\n  margin-bottom: 12px;\n  box-shadow: 0 4px 15px rgba(0, 119, 181, 0.3);\n}\n\n.btn-primary:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(0, 119, 181, 0.4);\n}\n\n.btn-primary:disabled {\n  background: #a0aec0;\n  cursor: not-allowed;\n  transform: none;\n  box-shadow: none;\n}\n\n.btn-secondary {\n  background: linear-gradient(135deg, #718096, #4a5568);\n  color: white;\n  width: 100%;\n  box-shadow: 0 4px 15px rgba(113, 128, 150, 0.3);\n}\n\n.btn-secondary:hover:not(:disabled) {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(113, 128, 150, 0.4);\n}\n\n.btn-secondary:disabled {\n  background: #a0aec0;\n  cursor: not-allowed;\n  transform: none;\n  box-shadow: none;\n}\n\n.btn-small {\n  padding: 8px 16px;\n  font-size: 12px;\n  margin-left: 12px;\n  background: linear-gradient(135deg, #48bb78, #38a169);\n  color: white;\n  width: auto;\n  box-shadow: 0 2px 8px rgba(72, 187, 120, 0.3);\n}\n\n.btn-small:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4);\n}\n\n/* Comment Split Section Styles */\n.comment-split-section {\n  border: 2px solid rgba(0, 119, 181, 0.1);\n  border-radius: 12px;\n  padding: 16px;\n  margin: 20px 0;\n  background: rgba(231, 243, 248, 0.3);\n}\n\n.comment-split-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n  flex-wrap: wrap;\n}\n\n.comment-split-header h4 {\n  margin: 0;\n  color: #0077b5;\n  font-size: 16px;\n  font-weight: 700;\n}\n\n.comment-split-header small {\n  color: #718096;\n  font-size: 12px;\n  flex: 1;\n  margin-left: 12px;\n}\n\n.reset-btn {\n  background: linear-gradient(135deg, #ed8936, #dd6b20) !important;\n  color: white;\n  font-size: 11px;\n  padding: 6px 12px;\n  margin: 0;\n  min-width: auto;\n}\n\n.reset-btn:hover {\n  background: linear-gradient(135deg, #dd6b20, #c05621) !important;\n}\n\n.form-row {\n  display: flex;\n  gap: 12px;\n}\n\n.form-group.half {\n  flex: 1;\n}\n\n.field-help {\n  color: #718096;\n  font-size: 11px;\n  font-style: italic;\n  margin-top: 4px;\n  display: block;\n}\n\n.error-message {\n  background: rgba(245, 101, 101, 0.1);\n  border: 1px solid rgba(245, 101, 101, 0.3);\n  color: #c53030;\n  padding: 8px 12px;\n  border-radius: 8px;\n  font-size: 12px;\n  margin-top: 12px;\n  font-weight: 600;\n}\n\n.split-totals {\n  text-align: center;\n  margin-top: 12px;\n  color: #4a5568;\n  font-weight: 600;\n}\n\n.split-totals span {\n  color: #0077b5;\n  font-weight: 700;\n}\n\n/* Enhanced input validation styles */\n.form-group input.error {\n  border-color: #f56565 !important;\n  box-shadow: 0 0 0 3px rgba(245, 101, 101, 0.1) !important;\n}\n\n.form-group input.success {\n  border-color: #48bb78 !important;\n}\n\n.stats {\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  padding: 20px;\n  margin: 24px 0;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.stat-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n  font-size: 14px;\n  padding: 12px 16px;\n  background: rgba(102, 126, 234, 0.05);\n  border-radius: 10px;\n  border-left: 4px solid #667eea;\n  transition: all 0.3s ease;\n}\n\n.stat-item:hover {\n  transform: translateX(4px);\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);\n}\n\n.stat-item:last-child {\n  margin-bottom: 0;\n}\n\n.stat-label {\n  color: #4a5568;\n  font-weight: 600;\n  display: flex;\n  align-items: center;\n}\n\n.stat-label::before {\n  content: \"ðŸ“Š\";\n  margin-right: 8px;\n  font-size: 16px;\n}\n\n.stat-item span:last-child {\n  font-weight: 700;\n  color: #667eea;\n  background: rgba(102, 126, 234, 0.1);\n  padding: 4px 12px;\n  border-radius: 20px;\n  min-width: 24px;\n  text-align: center;\n}\n\n.logs {\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  padding: 20px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.logs h4 {\n  margin: 0 0 16px 0;\n  color: #4a5568;\n  font-size: 16px;\n  font-weight: 700;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  display: flex;\n  align-items: center;\n}\n\n.logs h4::before {\n  content: \"ðŸ“\";\n  margin-right: 8px;\n  font-size: 18px;\n}\n\n#logContainer {\n  max-height: 150px;\n  overflow-y: auto;\n  font-size: 13px;\n  color: #4a5568;\n  background: rgba(248, 250, 252, 0.7);\n  border-radius: 12px;\n  padding: 12px;\n}\n\n#logContainer::-webkit-scrollbar {\n  width: 6px;\n}\n\n#logContainer::-webkit-scrollbar-track {\n  background: rgba(226, 232, 240, 0.3);\n  border-radius: 3px;\n}\n\n#logContainer::-webkit-scrollbar-thumb {\n  background: rgba(102, 126, 234, 0.5);\n  border-radius: 3px;\n}\n\n#logContainer::-webkit-scrollbar-thumb:hover {\n  background: rgba(102, 126, 234, 0.7);\n}\n\n.log-entry {\n  padding: 8px 12px;\n  margin-bottom: 4px;\n  border-radius: 8px;\n  background: rgba(255, 255, 255, 0.6);\n  border-left: 3px solid #e2e8f0;\n  transition: all 0.2s ease;\n}\n\n.log-entry:hover {\n  background: rgba(255, 255, 255, 0.9);\n  transform: translateX(2px);\n}\n\n.log-entry:last-child {\n  margin-bottom: 0;\n}\n\n.log-time {\n  color: #a0aec0;\n  font-size: 11px;\n  font-weight: 500;\n}\n\n.log-error {\n  color: #f56565;\n  font-weight: 600;\n}\n\n.log-success {\n  color: #48bb78;\n  font-weight: 600;\n}\n\n.checkbox-group {\n  display: flex;\n  gap: 20px;\n  margin-top: 12px;\n}\n\n.checkbox-label {\n  display: flex;\n  align-items: center;\n  font-weight: 500;\n  margin-bottom: 0;\n  cursor: pointer;\n  padding: 8px 12px;\n  border-radius: 8px;\n  transition: all 0.3s ease;\n  background: rgba(102, 126, 234, 0.05);\n  border: 1px solid rgba(102, 126, 234, 0.1);\n}\n\n.checkbox-label:hover {\n  background: rgba(102, 126, 234, 0.1);\n  transform: translateY(-1px);\n}\n\n.checkbox-label input[type=\"checkbox\"] {\n  width: 18px;\n  height: 18px;\n  margin-right: 8px;\n  margin-bottom: 0;\n  accent-color: #667eea;\n  cursor: pointer;\n}\n\n.controls {\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  padding: 20px;\n  margin: 24px 0;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.form-row {\n  display: flex;\n  gap: 12px;\n}\n\n.form-group.half {\n  flex: 1;\n}\n\n.form-help {\n  font-size: 12px;\n  color: #a0aec0;\n  margin-top: 4px;\n  display: block;\n}\n\n.comment-split-section {\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 12px;\n  padding: 16px;\n  margin-top: 12px;\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.comment-split-header {\n  margin-bottom: 12px;\n}\n\n.comment-split-header h4 {\n  margin: 0 0 4px 0;\n  font-size: 14px;\n  font-weight: 600;\n  color: #2d3748;\n}\n\n.comment-split-header small {\n  font-size: 11px;\n  color: #718096;\n  font-style: italic;\n}\n\n.comment-split-section input[readonly] {\n  background: rgba(255, 255, 255, 0.6);\n  color: #4a5568;\n  cursor: not-allowed;\n}\n\n.mode-explanation {\n  font-size: 12px;\n  color: #4a5568;\n  background: rgba(102, 126, 234, 0.05);\n  padding: 8px 12px;\n  border-radius: 8px;\n  margin-top: 8px;\n  border-left: 3px solid #667eea;\n}\n\n.logs-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n}\n\n.logs-header h4 {\n  margin: 0;\n}\n","size_bytes":10403},"popup.js":{"content":"// LinkedIn AI Engagement Bot - Popup Script\n\nclass PopupController {\n  constructor() {\n    this.isRunning = false;\n    this.stats = {\n      postsFound: 0,\n      postsLiked: 0,\n      commentsPosted: 0,\n      errors: 0\n    };\n    this.globalLogs = [];\n    \n    this.initializeElements();\n    this.loadStoredData();\n    this.setupEventListeners();\n    this.setupMessageListener();\n  }\n\n  initializeElements() {\n    this.elements = {\n      apiKey: document.getElementById('apiKey'),\n      saveKey: document.getElementById('saveKey'),\n      maxPosts: document.getElementById('maxPosts'),\n      maxLikes: document.getElementById('maxLikes'),\n      singleWordComments: document.getElementById('singleWordComments'),\n      adaptiveComments: document.getElementById('adaptiveComments'),\n      resetSplit: document.getElementById('resetSplit'),\n      splitSubtitle: document.getElementById('splitSubtitle'),\n      splitError: document.getElementById('splitError'),\n      splitTotal: document.getElementById('splitTotal'),\n      delayMin: document.getElementById('delayMin'),\n      delayMax: document.getElementById('delayMax'),\n      startBot: document.getElementById('startBot'),\n      stopBot: document.getElementById('stopBot'),\n      downloadLogs: document.getElementById('downloadLogs'),\n      status: document.getElementById('status'),\n      postsFound: document.getElementById('postsFound'),\n      postsLiked: document.getElementById('postsLiked'),\n      commentsPosted: document.getElementById('commentsPosted'),\n      errors: document.getElementById('errors'),\n      logContainer: document.getElementById('logContainer')\n    };\n    \n    // Initialize split state\n    this.isSplitOverridden = false;\n  }\n\n  async loadStoredData() {\n    try {\n      const result = await chrome.storage.sync.get([\n        'openaiApiKey',\n        'maxPosts',\n        'maxLikes',\n        'singleWordComments',\n        'adaptiveComments', \n        'isSplitOverridden',\n        'delayMin',\n        'delayMax',\n        'stats',\n        'globalLogs'\n      ]);\n\n      if (result.openaiApiKey) {\n        this.elements.apiKey.value = result.openaiApiKey;\n      }\n\n      if (result.maxPosts) {\n        this.elements.maxPosts.value = result.maxPosts;\n      }\n\n      if (result.maxLikes) {\n        this.elements.maxLikes.value = result.maxLikes;\n      }\n\n      if (result.delayMin) {\n        this.elements.delayMin.value = result.delayMin;\n      }\n\n      if (result.delayMax) {\n        this.elements.delayMax.value = result.delayMax;\n      }\n\n      // Load split state\n      this.isSplitOverridden = result.isSplitOverridden || false;\n      \n      if (this.isSplitOverridden && result.singleWordComments !== undefined && result.adaptiveComments !== undefined) {\n        this.elements.singleWordComments.value = result.singleWordComments;\n        this.elements.adaptiveComments.value = result.adaptiveComments;\n        this.updateSplitDisplay();\n      } else {\n        // Calculate default 70/30 split\n        this.applyDefaultSplit();\n      }\n\n      if (result.stats) {\n        this.stats = { ...this.stats, ...result.stats };\n        this.updateStatsDisplay();\n      }\n\n      if (result.globalLogs) {\n        this.globalLogs = result.globalLogs || [];\n      }\n    } catch (error) {\n      this.addLog('Error loading stored data: ' + error.message, 'error');\n    }\n  }\n\n  setupEventListeners() {\n    this.elements.saveKey.addEventListener('click', () => this.saveApiKey());\n    this.elements.startBot.addEventListener('click', () => this.startBot());\n    this.elements.stopBot.addEventListener('click', () => this.stopBot());\n    this.elements.downloadLogs.addEventListener('click', () => this.downloadGlobalLogs());\n    \n    // Save settings on change\n    this.elements.maxPosts.addEventListener('input', () => {\n      if (!this.isSplitOverridden) {\n        this.applyDefaultSplit();\n      } else {\n        this.validateSplitInputs();\n      }\n      this.saveSettings();\n    });\n    \n    // Comment split event listeners\n    this.elements.singleWordComments.addEventListener('input', (e) => {\n      this.isSplitOverridden = true;\n      this.updateSplitSubtitle();\n      this.handleSplitChange('single', parseInt(e.target.value) || 0);\n    });\n    \n    this.elements.adaptiveComments.addEventListener('input', (e) => {\n      this.isSplitOverridden = true;\n      this.updateSplitSubtitle();\n      this.handleSplitChange('adaptive', parseInt(e.target.value) || 0);\n    });\n    \n    this.elements.resetSplit.addEventListener('click', () => {\n      this.resetToDefaultSplit();\n    });\n    \n    this.elements.maxLikes.addEventListener('change', () => this.saveSettings());\n    this.elements.delayMin.addEventListener('change', () => this.saveSettings());\n    this.elements.delayMax.addEventListener('change', () => this.saveSettings());\n  }\n\n  setupMessageListener() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      switch (message.type) {\n        case 'STATUS_UPDATE':\n          this.updateStatus(message.status);\n          break;\n        case 'STATS_UPDATE':\n          this.updateStats(message.stats);\n          break;\n        case 'LOG_MESSAGE':\n          this.addLog(message.message, message.level);\n          break;\n        case 'BOT_STOPPED':\n          this.handleBotStopped();\n          break;\n      }\n    });\n  }\n\n  async saveApiKey() {\n    const apiKey = this.elements.apiKey.value.trim();\n    \n    if (!apiKey) {\n      this.addLog('Please enter a valid OpenAI API key', 'error');\n      return;\n    }\n\n    if (!apiKey.startsWith('sk-')) {\n      this.addLog('Invalid OpenAI API key format', 'error');\n      return;\n    }\n\n    try {\n      await chrome.storage.sync.set({ openaiApiKey: apiKey });\n      this.addLog('API key saved successfully', 'success');\n    } catch (error) {\n      this.addLog('Error saving API key: ' + error.message, 'error');\n    }\n  }\n\n  // Comment Split Logic Methods\n  applyDefaultSplit() {\n    const totalPosts = parseInt(this.elements.maxPosts.value) || 10;\n    const singleWordCount = Math.ceil(totalPosts * 0.7);\n    const adaptiveCount = totalPosts - singleWordCount;\n    \n    this.elements.singleWordComments.value = singleWordCount;\n    this.elements.adaptiveComments.value = adaptiveCount;\n    \n    this.isSplitOverridden = false;\n    this.updateSplitDisplay();\n    this.updateSplitSubtitle();\n    this.clearSplitError();\n    this.saveSettings();\n  }\n  \n  resetToDefaultSplit() {\n    this.applyDefaultSplit();\n    this.addLog('Comment split reset to default 70/30 distribution', 'success');\n  }\n  \n  handleSplitChange(changedField, newValue) {\n    const totalPosts = parseInt(this.elements.maxPosts.value) || 10;\n    const currentSingle = parseInt(this.elements.singleWordComments.value) || 0;\n    const currentAdaptive = parseInt(this.elements.adaptiveComments.value) || 0;\n    \n    // Validate bounds\n    if (newValue < 0) {\n      newValue = 0;\n    } else if (newValue > totalPosts) {\n      newValue = totalPosts;\n    }\n    \n    // Auto-adjust the other field\n    if (changedField === 'single') {\n      const adaptiveValue = totalPosts - newValue;\n      this.elements.singleWordComments.value = newValue;\n      this.elements.adaptiveComments.value = adaptiveValue;\n    } else {\n      const singleValue = totalPosts - newValue;\n      this.elements.adaptiveComments.value = newValue;\n      this.elements.singleWordComments.value = singleValue;\n    }\n    \n    this.validateSplitInputs();\n    this.updateSplitDisplay();\n    this.saveSettings();\n  }\n  \n  validateSplitInputs() {\n    const totalPosts = parseInt(this.elements.maxPosts.value) || 10;\n    const singleWordCount = parseInt(this.elements.singleWordComments.value) || 0;\n    const adaptiveCount = parseInt(this.elements.adaptiveComments.value) || 0;\n    const sum = singleWordCount + adaptiveCount;\n    \n    // Clear previous validation styles\n    this.elements.singleWordComments.classList.remove('error', 'success');\n    this.elements.adaptiveComments.classList.remove('error', 'success');\n    \n    if (sum !== totalPosts) {\n      this.showSplitError(`Values must add up to ${totalPosts} total posts (currently: ${sum})`);\n      this.elements.singleWordComments.classList.add('error');\n      this.elements.adaptiveComments.classList.add('error');\n      return false;\n    } else if (singleWordCount < 0 || adaptiveCount < 0) {\n      this.showSplitError('Values cannot be negative');\n      if (singleWordCount < 0) this.elements.singleWordComments.classList.add('error');\n      if (adaptiveCount < 0) this.elements.adaptiveComments.classList.add('error');\n      return false;\n    } else {\n      this.clearSplitError();\n      this.elements.singleWordComments.classList.add('success');\n      this.elements.adaptiveComments.classList.add('success');\n      return true;\n    }\n  }\n  \n  updateSplitDisplay() {\n    const singleWordCount = parseInt(this.elements.singleWordComments.value) || 0;\n    const adaptiveCount = parseInt(this.elements.adaptiveComments.value) || 0;\n    const total = singleWordCount + adaptiveCount;\n    \n    this.elements.splitTotal.textContent = total;\n  }\n  \n  updateSplitSubtitle() {\n    if (this.isSplitOverridden) {\n      this.elements.splitSubtitle.textContent = \"Custom split (manually adjusted)\";\n      this.elements.splitSubtitle.style.color = \"#ed8936\";\n    } else {\n      this.elements.splitSubtitle.textContent = \"Auto-calculated (70% single-word, 30% adaptive)\";\n      this.elements.splitSubtitle.style.color = \"#718096\";\n    }\n  }\n  \n  showSplitError(message) {\n    this.elements.splitError.textContent = message;\n    this.elements.splitError.style.display = 'block';\n  }\n  \n  clearSplitError() {\n    this.elements.splitError.style.display = 'none';\n  }\n\n  async saveSettings() {\n    try {\n      await chrome.storage.sync.set({\n        maxPosts: parseInt(this.elements.maxPosts.value),\n        maxLikes: parseInt(this.elements.maxLikes.value),\n        singleWordComments: parseInt(this.elements.singleWordComments.value),\n        adaptiveComments: parseInt(this.elements.adaptiveComments.value),\n        isSplitOverridden: this.isSplitOverridden,\n        delayMin: parseInt(this.elements.delayMin.value),\n        delayMax: parseInt(this.elements.delayMax.value)\n      });\n    } catch (error) {\n      this.addLog('Error saving settings: ' + error.message, 'error');\n    }\n  }\n\n  async startBot() {\n    const apiKey = this.elements.apiKey.value.trim();\n    \n    if (!apiKey || !apiKey.startsWith('sk-')) {\n      this.addLog('Please save a valid OpenAI API key first', 'error');\n      return;\n    }\n\n\n    try {\n      // Get current active tab\n      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      \n      if (!tab.url.includes('linkedin.com')) {\n        this.addLog('Please navigate to LinkedIn first', 'error');\n        return;\n      }\n\n      // Ensure content script is injected and ready\n      try {\n        await chrome.scripting.executeScript({\n          target: { tabId: tab.id },\n          files: ['config.js', 'content.js']\n        });\n        \n        // Small delay to ensure script initialization\n        await new Promise(resolve => setTimeout(resolve, 500));\n      } catch (scriptError) {\n        // Content script might already be loaded, continue\n        console.log('Content script injection result:', scriptError.message);\n      }\n\n      // Test connection with ping\n      try {\n        await chrome.tabs.sendMessage(tab.id, { type: 'PING' });\n      } catch (pingError) {\n        throw new Error('Content script not responding. Please refresh the LinkedIn page and try again.');\n      }\n\n      // Send start message to content script\n      const maxPosts = parseInt(this.elements.maxPosts.value);\n      const singleWordCount = parseInt(this.elements.singleWordComments.value);\n      const explanatoryCount = parseInt(this.elements.explanatoryComments.value);\n      \n      await chrome.tabs.sendMessage(tab.id, {\n        type: 'START_BOT',\n        config: {\n          apiKey: apiKey,\n          maxPosts: maxPosts,\n          enableLikes: true,\n          enableComments: true,\n          maxLikes: parseInt(this.elements.maxLikes.value),\n          maxComments: maxPosts, // Total comments = total posts to process\n          singleWordComments: singleWordCount,\n          explanatoryComments: explanatoryCount,\n          delayMin: parseInt(this.elements.delayMin.value),\n          delayMax: parseInt(this.elements.delayMax.value)\n        }\n      });\n\n      this.isRunning = true;\n      this.updateUIState();\n      this.updateStatus('Starting bot...');\n      this.clearCurrentLogs(); // Clear UI logs but keep global logs\n      this.addLog('Bot started successfully', 'success');\n      \n    } catch (error) {\n      this.addLog('Error starting bot: ' + error.message, 'error');\n    }\n  }\n\n  async stopBot() {\n    try {\n      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      \n      try {\n        await chrome.tabs.sendMessage(tab.id, { type: 'STOP_BOT' });\n      } catch (messageError) {\n        // Content script might not be responsive, that's ok\n        console.log('Stop message result:', messageError.message);\n      }\n      \n      this.handleBotStopped();\n      this.addLog('Bot stopped', 'success');\n      \n    } catch (error) {\n      this.addLog('Error stopping bot: ' + error.message, 'error');\n      this.handleBotStopped(); // Force stop UI state\n    }\n  }\n\n  handleBotStopped() {\n    this.isRunning = false;\n    this.updateUIState();\n    this.updateStatus('Ready');\n  }\n\n  updateUIState() {\n    this.elements.startBot.disabled = this.isRunning;\n    this.elements.stopBot.disabled = !this.isRunning;\n    this.elements.apiKey.disabled = this.isRunning;\n    this.elements.maxPosts.disabled = this.isRunning;\n  }\n\n  updateStatus(status) {\n    this.elements.status.textContent = status;\n    this.elements.status.className = 'status';\n    \n    if (status.toLowerCase().includes('error')) {\n      this.elements.status.classList.add('error');\n    } else if (status.toLowerCase().includes('running') || status.toLowerCase().includes('processing')) {\n      this.elements.status.classList.add('running');\n    }\n  }\n\n  updateStats(newStats) {\n    this.stats = { ...this.stats, ...newStats };\n    this.updateStatsDisplay();\n    this.saveStatsToStorage();\n  }\n\n  updateStatsDisplay() {\n    this.elements.postsFound.textContent = this.stats.postsFound || 0;\n    this.elements.postsLiked.textContent = this.stats.postsLiked || 0;\n    this.elements.commentsPosted.textContent = this.stats.commentsPosted || 0;\n    this.elements.errors.textContent = this.stats.errors || 0;\n  }\n\n  async saveStatsToStorage() {\n    try {\n      await chrome.storage.sync.set({ stats: this.stats });\n    } catch (error) {\n      console.error('Error saving stats:', error);\n    }\n  }\n\n  addLog(message, level = 'info') {\n    const timestamp = new Date();\n    const timeStr = timestamp.toLocaleTimeString();\n    \n    // Add to global logs with full timestamp\n    this.globalLogs.push({\n      timestamp: timestamp.toISOString(),\n      time: timeStr,\n      message: message,\n      level: level\n    });\n    \n    // Save global logs to storage\n    this.saveGlobalLogs();\n    \n    // Display in UI\n    const logEntry = document.createElement('div');\n    logEntry.className = 'log-entry';\n    \n    const timeSpan = document.createElement('span');\n    timeSpan.className = 'log-time';\n    timeSpan.textContent = `[${timeStr}] `;\n    \n    const messageSpan = document.createElement('span');\n    messageSpan.textContent = message;\n    \n    if (level === 'error') {\n      messageSpan.className = 'log-error';\n    } else if (level === 'success') {\n      messageSpan.className = 'log-success';\n    }\n    \n    logEntry.appendChild(timeSpan);\n    logEntry.appendChild(messageSpan);\n    \n    this.elements.logContainer.appendChild(logEntry);\n    this.elements.logContainer.scrollTop = this.elements.logContainer.scrollHeight;\n    \n    // Keep only last 50 entries in UI\n    while (this.elements.logContainer.children.length > 50) {\n      this.elements.logContainer.removeChild(this.elements.logContainer.firstChild);\n    }\n  }\n\n  // Removed - replaced with applyDefaultSplit() method above\n\n  clearCurrentLogs() {\n    this.elements.logContainer.innerHTML = '';\n  }\n\n  async saveGlobalLogs() {\n    try {\n      // Keep only last 1000 logs to prevent storage overflow\n      if (this.globalLogs.length > 1000) {\n        this.globalLogs = this.globalLogs.slice(-1000);\n      }\n      \n      await chrome.storage.sync.set({ globalLogs: this.globalLogs });\n    } catch (error) {\n      console.error('Error saving global logs:', error);\n    }\n  }\n\n  downloadGlobalLogs() {\n    if (this.globalLogs.length === 0) {\n      this.addLog('No logs available to download', 'info');\n      return;\n    }\n    \n    // Create downloadable content\n    const logContent = this.globalLogs.map(log => \n      `${log.timestamp} [${log.level.toUpperCase()}] ${log.message}`\n    ).join('\\\\n');\n    \n    // Create and trigger download\n    const blob = new Blob([logContent], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `linkedin-bot-logs-${new Date().toISOString().split('T')[0]}.txt`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n    \n    this.addLog(`Downloaded ${this.globalLogs.length} log entries`, 'success');\n  }\n}\n\n// Initialize popup controller when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  new PopupController();\n});\n","size_bytes":17554},"replit.md":{"content":"# LinkedIn AI Engagement Bot\n\n## Overview\n\nThis is a Chrome browser extension that automates LinkedIn engagement through AI-generated comments. The bot scans LinkedIn feeds, extracts post content, generates contextually appropriate comments using OpenAI's GPT-4o model, and automatically posts them to increase user engagement on the platform. The extension uses a human-like interaction pattern with configurable delays and comment styles to avoid detection as an automated tool.\n\n## Recent Changes (August 22, 2025)\n\n### AI-Powered Smart Engagement System\n- **Smart Adaptive Comments**: AI automatically chooses response style based on post content (job announcements, achievements, insights, personal stories)\n- **Natural Expressions**: Added \"haha\", \"wow\", \"love this\", \"so true\" and professional emojis for authentic engagement\n- **Variable Comment Length**: Comments range from 1-4 lines, with many being short and natural (not every comment is long)\n- **Advertisement Detection**: Automatically skips sponsored posts and ads to avoid spam-like behavior\n- **Engagement Checking**: Detects already liked/commented posts and skips them to prevent duplicate actions\n- **Context-Aware Responses**: Job posts get congratulations, achievements get praise, insights get thoughtful questions\n\n### Advanced Feature Update (August 21, 2025)\n- **Post Liking Feature**: Added automatic post liking with smart detection of already-liked posts\n- **Flexible Action Controls**: Users can now enable/disable likes and comments independently  \n- **Advanced Limits System**: Separate controls for max posts to like (1-100) and comment (1-50)\n- **Human-like Behavior**: Implemented randomized delays between actions (user-configurable range)\n- **Action Randomization**: Bot randomly shuffles like/comment order to appear more natural\n- **Enhanced Statistics**: Added real-time tracking for posts liked in addition to comments posted\n\n### Technical Improvements (August 20, 2025)\n- Fixed browser compatibility issues (removed Node.js process.env usage)\n- Updated LinkedIn DOM selectors for current site structure  \n- Enhanced content extraction with fallback methods\n- Improved comment posting with better rich text editor support\n- Added comprehensive debugging and logging\n- Created test page for API key validation\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Chrome Extension Architecture\n- **Manifest V3 Structure**: Uses service worker background script pattern for modern Chrome extension development\n- **Multi-Script Architecture**: Separates concerns across background.js (API calls), content.js (DOM manipulation), popup.js (UI control), and config.js (settings)\n- **Message Passing System**: Implements Chrome extension message passing between popup, content script, and background service worker for coordinated actions\n\n### Content Script Strategy\n- **DOM Monitoring**: Uses CSS selectors to identify LinkedIn feed posts, comment buttons, and text editors\n- **Human-like Automation**: Implements configurable delays between actions (scrolling, clicking, typing) to mimic human behavior\n- **State Management**: Tracks processed posts to avoid duplicate comments and maintains running statistics\n\n### AI Integration\n- **OpenAI GPT-4o Integration**: Direct API calls to OpenAI's chat completions endpoint for comment generation\n- **Comment Style Customization**: Supports multiple comment styles (professional, casual, insightful, supportive) through prompt engineering\n- **Content Context Awareness**: Extracts post content and generates relevant, contextual responses\n\n### User Interface Design\n- **Popup-based Control Panel**: Browser extension popup provides configuration interface and bot controls\n- **Real-time Status Updates**: Live statistics tracking and status indicators for bot operation\n- **Persistent Settings**: Chrome storage API for saving API keys and user preferences\n\n### Security and Privacy\n- **API Key Management**: Secure storage of OpenAI API key using Chrome's sync storage\n- **Content Script Isolation**: Runs in isolated context on LinkedIn pages without interfering with site functionality\n- **Error Handling**: Comprehensive error management and logging for debugging and user feedback\n\n## External Dependencies\n\n### APIs and Services\n- **OpenAI API**: GPT-4o model for natural language comment generation\n- **Chrome Extensions API**: Storage, messaging, and content script injection capabilities\n\n### Target Platform\n- **LinkedIn Web Platform**: Specifically designed for LinkedIn.com feed interaction and engagement\n- **DOM Selectors**: Relies on LinkedIn's current HTML structure and CSS classes for automation\n\n### Node.js Dependencies\n- **OpenAI Package**: Version 5.13.1 for API client functionality (though primarily used for reference in browser context)\n\n### Browser Requirements\n- **Chrome Browser**: Manifest V3 compatible Chrome browser for extension hosting\n- **LinkedIn Session**: Requires active LinkedIn login session for feed access and comment posting","size_bytes":5059},".local/state/replit/agent/progress_tracker.md":{"content":"[x] 1. Install the required packages\n[x] 2. Restart the workflow to see if the project is working\n[x] 3. Verify the project is working using the feedback tool\n[x] 4. Inform user the import is completed and they can start building, mark the import as completed using the complete_project_import tool\n[x] 5. Update OpenAI prompt for 1-word comments with Indian-English micro-responder approach\n[x] 6. Fix counting logic to only count successful actions toward target numbers (skipped posts don't count)\n[x] 7. Fix engagement checking to only skip if YOU have already engaged (not others)\n[x] 8. Improve ad detection to reduce false positives on regular posts  \n[x] 9. Update processing to continue until target numbers are reached regardless of skips","size_bytes":748}},"version":1}