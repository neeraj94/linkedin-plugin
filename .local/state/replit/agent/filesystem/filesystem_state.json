{"file_contents":{"README.md":{"content":"# LinkedIn AI Engagement Bot\n\nA Chrome extension that automatically finds posts in your LinkedIn feed, generates AI-powered comments using OpenAI's GPT-4o, and posts them to increase your professional engagement.\n\n## Features\n\n- üîç **Smart Feed Scanning**: Automatically finds and analyzes LinkedIn posts\n- ü§ñ **AI-Powered Comments**: Uses OpenAI GPT-4o for contextual, professional responses\n- ‚ù§Ô∏è **Post Liking**: Automatically likes posts to increase engagement\n- üéØ **Multiple Comment Styles**: Professional, Casual, Insightful, or Supportive tones\n- ‚öôÔ∏è **Flexible Limits**: Separate controls for posts to like (1-100) and comment (1-50)\n- üïí **Human-like Behavior**: Random delays and action shuffling to avoid detection\n- üìä **Real-time Analytics**: Live statistics for posts found, liked, and commented\n- üíæ **Smart Settings**: Persistent configuration with automatic saving\n- üé≤ **Randomized Delays**: Custom delay ranges for natural interaction patterns\n\n## Installation\n\n1. **Download the Extension Files**\n   - Download all files from this project to a folder on your computer\n\n2. **Install in Chrome**\n   - Open Chrome and go to `chrome://extensions/`\n   - Enable \"Developer mode\" (toggle in top right)\n   - Click \"Load unpacked\"\n   - Select the folder containing the extension files\n\n3. **Set Up OpenAI API Key**\n   - Get an API key from [OpenAI Platform](https://platform.openai.com/api-keys)\n   - Click the extension icon in Chrome\n   - Enter your API key and click \"Save\"\n\n## How to Use\n\n1. **Navigate to LinkedIn**\n   - Go to [LinkedIn.com](https://linkedin.com) and log in\n   - Make sure you're on your main feed page\n\n2. **Configure Settings**\n   - Click the extension icon in your browser toolbar\n   - **Actions**: Enable/disable liking posts and commenting\n   - **Limits**: Set max posts to like (default: 15) and comment (default: 5)\n   - **Style**: Choose your preferred comment tone\n   - **Delays**: Set random delay range between actions (default: 2-8 seconds)\n\n3. **Start the Bot**\n   - Click \"Start Engagement\"\n   - The bot will automatically:\n     - Scan your feed for posts\n     - Like posts based on your settings\n     - Generate and post AI comments\n     - Use random delays to appear human-like\n   - Monitor real-time progress in the activity log\n\n4. **Advanced Controls**\n   - **Smart Limits**: Bot stops when like/comment limits are reached\n   - **Human Behavior**: Random action order and variable timing\n   - **Live Stats**: Track posts found, liked, and commented in real-time\n   - **Stop Anytime**: Immediately halt all bot activity\n\n## Comment Styles\n\n- **Professional**: Business-focused, formal language with industry insights\n- **Casual**: Friendly, conversational tone while remaining professional\n- **Insightful**: Thoughtful analysis with meaningful questions\n- **Supportive**: Encouraging responses that build others up\n\n## Important Notes\n\n‚ö†Ô∏è **Use Responsibly**\n- This tool is for educational purposes\n- Be aware of LinkedIn's Terms of Service\n- Use reasonable delays and limits to avoid account restrictions\n- Monitor your account activity regularly\n\nüîí **Privacy & Security**\n- Your API key is stored locally in Chrome storage\n- No data is sent to external servers except OpenAI for comment generation\n- The extension only works on LinkedIn pages\n\n## Troubleshooting\n\n**Bot won't start?**\n- Make sure you're on LinkedIn.com\n- Check that your OpenAI API key is valid\n- Ensure you have sufficient OpenAI API credits\n\n**Comments not posting?**\n- LinkedIn may have updated their interface\n- Try refreshing the page and restarting the bot\n- Check the activity log for specific error messages\n\n**Extension not appearing?**\n- Make sure Developer mode is enabled in Chrome extensions\n- Try reloading the extension from `chrome://extensions/`\n\n## Technical Details\n\n- Built with Manifest V3 for modern Chrome extensions\n- Uses OpenAI GPT-4o model for intelligent comment generation\n- Implements human-like interaction patterns with configurable delays\n- Content script isolation for secure LinkedIn integration\n\n---\n\n**Disclaimer**: This extension is for educational purposes. Users are responsible for complying with LinkedIn's Terms of Service and using the tool ethically.","size_bytes":4243},"background.js":{"content":"// LinkedIn AI Engagement Bot - Background Script\n\nclass BackgroundService {\n  constructor() {\n    this.setupMessageListener();\n  }\n\n  setupMessageListener() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      switch (message.type) {\n        case 'GENERATE_COMMENT':\n          this.handleCommentGeneration(message, sendResponse);\n          return true; // Keep the message channel open for async response\n        case 'LOG_ERROR':\n          console.error('Content Script Error:', message.error);\n          break;\n      }\n    });\n  }\n\n  async handleCommentGeneration(message, sendResponse) {\n    try {\n      const { postContent, commentStyle, apiKey } = message;\n      \n      // Use provided key (environment variables not available in browser context)\n      const openaiKey = apiKey;\n      \n      if (!openaiKey || !openaiKey.startsWith('sk-')) {\n        throw new Error('Invalid OpenAI API key');\n      }\n\n      const result = await this.generateComment(postContent, commentStyle, openaiKey);\n      \n      sendResponse({\n        success: true,\n        result: result\n      });\n      \n    } catch (error) {\n      console.error('Error generating comment:', error);\n      \n      sendResponse({\n        success: false,\n        error: error.message\n      });\n    }\n  }\n\n  async generateComment(postContent, commentStyle, apiKey) {\n    // the newest OpenAI model is \"gpt-4o\" which was released May 13, 2024. do not change this unless explicitly requested by the user\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o',\n        messages: [\n          {\n            role: 'system',\n            content: this.getSystemPrompt(commentStyle)\n          },\n          {\n            role: 'user',\n            content: `Please generate a ${commentStyle} LinkedIn comment for this post:\\n\\n${postContent}\\n\\nRespond with JSON in this format: { \"comment\": \"your comment here\" }`\n          }\n        ],\n        response_format: { type: 'json_object' },\n        max_tokens: 150,\n        temperature: 0.7\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new Error(`OpenAI API Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);\n    }\n\n    const data = await response.json();\n    \n    if (!data.choices || !data.choices[0] || !data.choices[0].message) {\n      throw new Error('Invalid response format from OpenAI API');\n    }\n\n    try {\n      const result = JSON.parse(data.choices[0].message.content);\n      \n      // Handle skip directive for ads/sponsored content\n      if (result.skip) {\n        return { skip: true, reason: result.reason || 'AI decided to skip this post' };\n      }\n      \n      if (!result.comment || typeof result.comment !== 'string') {\n        throw new Error('Invalid comment format in API response');\n      }\n\n      return { comment: result.comment.trim(), skip: false };\n      \n    } catch (parseError) {\n      throw new Error('Failed to parse OpenAI response: ' + parseError.message);\n    }\n  }\n\n  getSystemPrompt(commentStyle) {\n    if (commentStyle === 'adaptive') {\n      return `You are a LinkedIn engagement expert. Analyze the post content and generate the most appropriate response based on context:\n\nPOST TYPE RESPONSES:\n- Job announcements/new positions: Brief congratulations (1-2 lines) like \"Congratulations! üéâ\", \"Exciting opportunity!\", \"Best of luck in your new role!\"\n- Achievement/milestone posts: Enthusiastic support like \"Amazing work! üëè\", \"Well deserved!\", \"So inspiring!\", \"Wow, incredible!\"\n- Industry insights/articles: Thoughtful responses with questions like \"Great points! Have you considered...?\", \"Love this perspective...\", \"This aligns with...\"\n- Personal stories: Warm, relatable responses like \"Love this!\", \"So true!\", \"Thanks for sharing!\", \"Haha, been there too!\"\n- Business updates/company news: Professional but engaging responses\n\nRULES:\n- Maximum 4 lines, often 1-2 lines is perfect\n- Use natural expressions: \"haha\", \"wow\", \"love this\", \"so true\", \"amazing\" when appropriate\n- Add professional emojis sparingly: üéâ üëè üí° üöÄ ‚ù§Ô∏è\n- Vary length - not every comment needs to be long\n- Be authentic and conversational\n- Skip obvious advertisements or sponsored content\n\nIf post appears to be an ad/sponsored content, return: {\"skip\": true, \"reason\": \"advertisement\"}\nOtherwise return: {\"comment\": \"your engaging comment\"}`;\n    }\n    \n    const basePrompt = `You are a LinkedIn engagement expert. Generate authentic, meaningful comments (max 4 lines). `;\n    \n    const stylePrompts = {\n      professional: `Professional tone with business insights. Use industry terminology and formal language.`,\n      casual: `Friendly, conversational tone while remaining professional. Be approachable and personable.`,\n      insightful: `Thoughtful analysis with meaningful questions. Be intellectually engaging and encourage discussion.`,\n      supportive: `Encouraging and supportive. Acknowledge achievements and build others up with positive reinforcement.`\n    };\n\n    const guidelines = `\n- Keep authentic and engaging (20-80 words)\n- Add value to the conversation  \n- Use proper grammar and appropriate emojis occasionally\n- Avoid generic responses and controversial topics`;\n\n    return basePrompt + (stylePrompts[commentStyle] || stylePrompts.professional) + guidelines;\n  }\n}\n\n// Initialize background service\nnew BackgroundService();\n","size_bytes":5641},"config.js":{"content":"// LinkedIn AI Engagement Bot - Configuration\n\nconst CONFIG = {\n  // Timing delays to appear more human-like (in milliseconds)\n  DELAYS: {\n    SCROLL: 1000,        // Delay after scrolling to post\n    CLICK: 500,          // Delay after clicking comment button\n    FOCUS: 300,          // Delay after focusing comment editor\n    TYPE: 1000,          // Delay after typing comment\n    SUBMIT: 1000,        // Delay after submitting comment\n    BETWEEN_POSTS: 3000  // Delay between processing posts\n  },\n\n  // LinkedIn selectors (may need updates if LinkedIn changes their DOM)\n  SELECTORS: {\n    FEED_POSTS: '.feed-shared-update-v2',\n    POST_CONTENT: [\n      '.feed-shared-text__text-view span[dir=\"ltr\"]',\n      '.feed-shared-text span[dir=\"ltr\"]',\n      '.feed-shared-update-v2__description span'\n    ],\n    COMMENT_BUTTON: [\n      '[aria-label*=\"omment\"]',\n      'button[data-control-name*=\"comment\"]',\n      '.social-actions-button:nth-child(2)'\n    ],\n    COMMENT_EDITOR: '.comments-comment-texteditor .ql-editor',\n    SUBMIT_BUTTON: '.comments-comment-texteditor .comments-comment-texteditor__submit-button:not([disabled])',\n    AUTHOR: [\n      '.feed-shared-actor__title a',\n      '.update-components-actor__title a'\n    ],\n    COMMENTS_SECTION: [\n      '.comments-comments-list',\n      '.social-details-social-comments'\n    ]\n  },\n\n  // Default settings\n  DEFAULTS: {\n    MAX_POSTS: 10,\n    MAX_LIKES: 15,\n    MAX_COMMENTS: 5,\n    COMMENT_STYLE: 'professional',\n    COMMENT_MIN_LENGTH: 20,\n    COMMENT_MAX_LENGTH: 80,\n    DELAY_MIN: 2,\n    DELAY_MAX: 8,\n    ENABLE_LIKES: true,\n    ENABLE_COMMENTS: true\n  },\n\n  // Error messages\n  ERRORS: {\n    NO_API_KEY: 'OpenAI API key is required',\n    INVALID_API_KEY: 'Invalid OpenAI API key format',\n    NOT_LINKEDIN: 'This extension only works on LinkedIn',\n    NO_POSTS_FOUND: 'No posts found in the current feed',\n    COMMENT_FAILED: 'Failed to post comment',\n    RATE_LIMITED: 'Rate limited by LinkedIn or OpenAI'\n  }\n};\n\n// Export config for other scripts\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = CONFIG;\n}\n","size_bytes":2096},"content.js":{"content":"// LinkedIn AI Engagement Bot - Content Script\n\nclass LinkedInBot {\n  constructor() {\n    this.isRunning = false;\n    this.config = {};\n    this.stats = {\n      postsFound: 0,\n      postsLiked: 0,\n      commentsPosted: 0,\n      errors: 0\n    };\n    this.processedPosts = new Set();\n    this.setupMessageListener();\n    \n    // Wait for page to be fully loaded\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => this.initialize());\n    } else {\n      this.initialize();\n    }\n  }\n\n  initialize() {\n    this.log('LinkedIn AI Bot initialized');\n  }\n\n  setupMessageListener() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      console.log('[LinkedIn Bot] Received message:', message.type);\n      \n      try {\n        switch (message.type) {\n          case 'START_BOT':\n            this.startBot(message.config);\n            sendResponse({ success: true, message: 'Bot started successfully' });\n            break;\n          case 'STOP_BOT':\n            this.stopBot();\n            sendResponse({ success: true, message: 'Bot stopped successfully' });\n            break;\n          case 'PING':\n            // Health check message\n            sendResponse({ success: true, message: 'Content script is active' });\n            break;\n          default:\n            sendResponse({ success: false, message: `Unknown message type: ${message.type}` });\n        }\n      } catch (error) {\n        console.error('[LinkedIn Bot] Message handler error:', error);\n        sendResponse({ success: false, message: error.message });\n      }\n      \n      return true; // Keep message channel open for async operations\n    });\n  }\n\n  async startBot(config) {\n    if (this.isRunning) {\n      this.log('Bot is already running', 'error');\n      return;\n    }\n\n    this.config = config;\n    this.isRunning = true;\n    this.processedPosts.clear();\n    \n    this.log('Starting LinkedIn engagement bot...');\n    this.updateStatus('Running - Scanning for posts...');\n    \n    try {\n      await this.processFeedPosts();\n    } catch (error) {\n      this.log('Bot execution error: ' + error.message, 'error');\n      this.updateStats({ errors: this.stats.errors + 1 });\n    } finally {\n      this.stopBot();\n    }\n  }\n\n  stopBot() {\n    this.isRunning = false;\n    this.log('Bot stopped');\n    this.sendMessage({ type: 'BOT_STOPPED' });\n  }\n\n  async processFeedPosts() {\n    const posts = await this.findFeedPosts();\n    \n    if (posts.length === 0) {\n      this.log('No posts found in feed', 'error');\n      this.updateStatus('No posts found');\n      return;\n    }\n\n    this.log(`Found ${posts.length} posts to process`);\n    this.updateStats({ postsFound: posts.length });\n    \n    let likesCount = 0;\n    let commentsCount = 0;\n    let processedCount = 0;\n    \n    for (const post of posts) {\n      if (!this.isRunning) {\n        this.log('Bot stopped during processing');\n        break;\n      }\n\n      if (processedCount >= this.config.maxPosts) {\n        this.log(`Reached maximum posts limit (${this.config.maxPosts})`);\n        break;\n      }\n\n      try {\n        const actions = [];\n        \n        // Determine what actions to perform on this post\n        if (this.config.enableLikes && likesCount < this.config.maxLikes) {\n          actions.push('like');\n        }\n        \n        if (this.config.enableComments && commentsCount < this.config.maxComments) {\n          actions.push('comment');\n        }\n\n        if (actions.length === 0) {\n          this.log('All action limits reached, stopping processing');\n          break;\n        }\n\n        const result = await this.processPost(post, actions);\n        \n        if (result.liked) likesCount++;\n        if (result.commented) commentsCount++;\n        \n        processedCount++;\n        \n        // Add random human-like delay between posts\n        const delay = this.getRandomDelay();\n        this.log(`Waiting ${delay}s before next post...`);\n        await this.delay(delay * 1000);\n        \n      } catch (error) {\n        this.log(`Error processing post: ${error.message}`, 'error');\n        this.updateStats({ errors: this.stats.errors + 1 });\n        \n        // Add delay even on error to avoid rapid retries\n        await this.delay(this.getRandomDelay() * 1000);\n      }\n    }\n\n    this.log(`Completed processing ${processedCount} posts (${likesCount} liked, ${commentsCount} commented)`);\n    this.updateStatus(`Completed - ${processedCount} processed, ${likesCount} liked, ${commentsCount} commented`);\n  }\n\n  async findFeedPosts() {\n    // Wait for feed to load - try multiple selectors\n    const feedLoaded = await this.waitForElement('.feed-shared-update-v2, .feed-shared-update-v2__container, [data-test-id=\"main-feed-activity-card\"]', 5000);\n    \n    if (!feedLoaded) {\n      this.log('Feed not loaded, trying alternative selectors');\n    }\n    \n    const posts = [];\n    // Try multiple selectors for feed posts\n    const postElements = document.querySelectorAll('.feed-shared-update-v2, [data-test-id=\"main-feed-activity-card\"], .feed-shared-update-v2__container');\n    \n    this.log(`Found ${postElements.length} potential post elements`);\n    \n    for (const postElement of postElements) {\n      if (posts.length >= this.config.maxPosts) break;\n      \n      try {\n        const postData = this.extractPostData(postElement);\n        \n        if (postData && !this.processedPosts.has(postData.id)) {\n          posts.push(postData);\n          this.processedPosts.add(postData.id);\n          this.log(`Successfully extracted post by ${postData.author}: \"${postData.content.substring(0, 50)}...\"`);\n        }\n      } catch (error) {\n        this.log(`Error extracting post data: ${error.message}`, 'error');\n        // Log more details for debugging\n        this.log(`Post element classes: ${postElement.className}`, 'info');\n      }\n    }\n    \n    return posts;\n  }\n\n  extractPostData(postElement) {\n    // Debug: Log post element structure\n    this.log(`Analyzing post element with classes: ${postElement.className}`);\n    \n    // Temporarily disable ad detection for debugging - check if posts can be extracted\n    // const isAd = this.isAdvertisement(postElement);\n    // if (isAd) {\n    //   this.log(`Detected sponsored content, skipping post`, 'info');\n    //   throw new Error('Skipping advertisement/sponsored post');\n    // }\n    \n    this.log(`Processing regular post for content extraction`, 'info');\n    \n    // Check if already engaged with this post\n    const alreadyEngaged = this.isAlreadyEngaged(postElement);\n    if (alreadyEngaged.liked && alreadyEngaged.commented) {\n      throw new Error('Already liked and commented on this post');\n    }\n    \n    // Find the post content using multiple selectors for LinkedIn's dynamic structure\n    const contentElement = postElement.querySelector('.feed-shared-text__text-view .break-words') ||\n                          postElement.querySelector('.feed-shared-text .break-words') ||\n                          postElement.querySelector('.feed-shared-update-v2__description .break-words') ||\n                          postElement.querySelector('.feed-shared-text__text-view span') ||\n                          postElement.querySelector('.feed-shared-text span') ||\n                          postElement.querySelector('.update-components-text span') ||\n                          postElement.querySelector('[data-test-id=\"main-feed-activity-card\"] .break-words') ||\n                          postElement.querySelector('.feed-shared-update-v2__description span') ||\n                          postElement.querySelector('.feed-shared-text__text-view') ||\n                          postElement.querySelector('.feed-shared-text') ||\n                          postElement.querySelector('.update-components-text');\n    \n    if (!contentElement) {\n      // Debug: Show what elements we can find\n      this.log(`No content element found with standard selectors`);\n      \n      const textElements = postElement.querySelectorAll('*');\n      const textElementsWithContent = Array.from(textElements).filter(el => \n        el.textContent && el.textContent.trim().length > 20 && \n        !el.querySelector('*') // Only leaf nodes\n      );\n      \n      this.log(`Found ${textElementsWithContent.length} potential text elements in fallback`);\n      \n      // Log first few text elements for debugging\n      textElementsWithContent.slice(0, 3).forEach((el, i) => {\n        this.log(`Text element ${i + 1}: \"${el.textContent.trim().substring(0, 50)}...\"`);\n      });\n      \n      if (textElementsWithContent.length > 0) {\n        this.log(`Using fallback method with first text element`);\n        return this.createPostDataFromFallback(postElement, textElementsWithContent[0]);\n      }\n      \n      throw new Error('Could not find post content - no text elements found');\n    }\n\n    // Get post ID (using data attributes or generating one)\n    let postId = postElement.getAttribute('data-urn') || \n                 postElement.getAttribute('data-id') ||\n                 postElement.querySelector('[data-urn]')?.getAttribute('data-urn');\n    \n    if (!postId) {\n      // Generate a unique ID based on content and position\n      postId = this.generatePostId(contentElement.textContent, postElement);\n    }\n\n    // Check if we can comment (look for comment button)\n    const commentButton = this.findCommentButton(postElement);\n    this.log(`Comment button found: ${!!commentButton}`);\n\n    if (!commentButton || commentButton.disabled) {\n      this.log(`Cannot comment - button missing or disabled`);\n      throw new Error('Cannot comment on this post');\n    }\n\n    // Extract author info\n    const authorElement = postElement.querySelector('.feed-shared-actor__title a') ||\n                         postElement.querySelector('.update-components-actor__title a') ||\n                         postElement.querySelector('.feed-shared-actor__name a') ||\n                         postElement.querySelector('.update-components-actor__name a');\n    \n    const authorName = authorElement ? authorElement.textContent.trim() : 'Unknown';\n\n    // Get engagement status\n    const engagementStatus = this.isAlreadyEngaged(postElement);\n\n    return {\n      id: postId,\n      content: contentElement.textContent.trim(),\n      author: authorName,\n      element: postElement,\n      commentButton: commentButton,\n      alreadyLiked: engagementStatus.liked,\n      alreadyCommented: engagementStatus.commented\n    };\n  }\n\n  createPostDataFromFallback(postElement, contentElement) {\n    // Get post ID\n    let postId = postElement.getAttribute('data-urn') || \n                 postElement.getAttribute('data-id') ||\n                 postElement.querySelector('[data-urn]')?.getAttribute('data-urn');\n    \n    if (!postId) {\n      postId = this.generatePostId(contentElement.textContent, postElement);\n    }\n\n    // Find comment button\n    const commentButton = this.findCommentButton(postElement);\n    if (!commentButton || commentButton.disabled) {\n      throw new Error('Cannot comment on this post');\n    }\n\n    // Extract author info\n    const authorElement = postElement.querySelector('.feed-shared-actor__title a') ||\n                         postElement.querySelector('.update-components-actor__title a') ||\n                         postElement.querySelector('.feed-shared-actor__name a') ||\n                         postElement.querySelector('.update-components-actor__name a');\n    \n    const authorName = authorElement ? authorElement.textContent.trim() : 'Unknown';\n\n    // Get engagement status\n    const engagementStatus = this.isAlreadyEngaged(postElement);\n\n    return {\n      id: postId,\n      content: contentElement.textContent.trim(),\n      author: authorName,\n      element: postElement,\n      commentButton: commentButton,\n      alreadyLiked: engagementStatus.liked,\n      alreadyCommented: engagementStatus.commented\n    };\n  }\n\n  isAdvertisement(postElement) {\n    // More specific checks for actual sponsored content\n    \n    // Check for specific promoted post indicators in the actor section\n    const actorElement = postElement.querySelector('.feed-shared-actor') || \n                        postElement.querySelector('.update-components-actor');\n    \n    if (actorElement) {\n      const actorText = actorElement.textContent;\n      \n      // Look for \"Promoted\" text specifically in actor description\n      if (actorText.includes('Promoted') || actorText.includes('Sponsored')) {\n        return true;\n      }\n    }\n    \n    // Check for promoted post specific classes\n    const hasPromotedClasses = postElement.querySelector('[data-promoted-post=\"true\"]') ||\n                              postElement.querySelector('.feed-shared-actor__sub-description:contains(\"Promoted\")') ||\n                              postElement.classList.contains('feed-shared-update-v2--promoted');\n    \n    // Check for sponsored content labels\n    const sponsoredLabels = postElement.querySelector('[aria-label*=\"Sponsored\"]') ||\n                           postElement.querySelector('[aria-label*=\"Promoted\"]');\n    \n    // Only flag as ad if we find specific promoted/sponsored indicators\n    return hasPromotedClasses || sponsoredLabels;\n  }\n\n  isAlreadyEngaged(postElement) {\n    // Check if already liked (liked button will have active/pressed state)\n    const likeButton = postElement.querySelector('[data-control-name=\"like\"]') ||\n                      postElement.querySelector('button[aria-label*=\"like\"]') ||\n                      postElement.querySelector('.react-button__trigger');\n    \n    const alreadyLiked = likeButton && (\n      likeButton.classList.contains('react-button__trigger--active') ||\n      likeButton.classList.contains('reactions-react-button--active') ||\n      likeButton.getAttribute('aria-pressed') === 'true' ||\n      likeButton.querySelector('.reaction-button--active')\n    );\n    \n    // Check if already commented (look for our previous comments)\n    const commentSection = postElement.querySelector('.comments-comment-box') ||\n                          postElement.querySelector('.social-details-social-counts');\n    \n    // Simple check - if we can see expanded comments, we might have commented\n    const alreadyCommented = commentSection && \n      (commentSection.querySelector('.comments-comment-item') || \n       commentSection.textContent.includes('comment'));\n    \n    return {\n      liked: !!alreadyLiked,\n      commented: !!alreadyCommented\n    };\n  }\n\n  findCommentButton(postElement) {\n    // Try multiple selectors for comment buttons\n    return postElement.querySelector('[aria-label*=\"Comment\"]') ||\n           postElement.querySelector('[aria-label*=\"comment\"]') ||\n           postElement.querySelector('button[data-control-name*=\"comment\"]') ||\n           postElement.querySelector('.social-actions-button[aria-label*=\"Comment\"]') ||\n           postElement.querySelector('.feed-shared-social-action-bar button[aria-label*=\"Comment\"]') ||\n           postElement.querySelector('.social-counts-reactions__comment-button') ||\n           postElement.querySelector('.feed-shared-social-action-bar .artdeco-button:nth-child(2)') ||\n           postElement.querySelector('.social-actions-button:nth-child(2)');\n  }\n\n  findLikeButton(postElement) {\n    // Try multiple selectors for like buttons\n    return postElement.querySelector('[aria-label*=\"Like\"]') ||\n           postElement.querySelector('[aria-label*=\"like\"]') ||\n           postElement.querySelector('button[data-control-name*=\"like\"]') ||\n           postElement.querySelector('.social-actions-button[aria-label*=\"Like\"]') ||\n           postElement.querySelector('.feed-shared-social-action-bar button[aria-label*=\"Like\"]') ||\n           postElement.querySelector('.reactions-react-button') ||\n           postElement.querySelector('.feed-shared-social-action-bar .artdeco-button:first-child') ||\n           postElement.querySelector('.social-actions-button:first-child');\n  }\n\n  async likePost(postData) {\n    try {\n      const likeButton = this.findLikeButton(postData.element);\n      \n      if (!likeButton) {\n        throw new Error('Like button not found');\n      }\n\n      // Check if already liked\n      const isLiked = likeButton.getAttribute('aria-pressed') === 'true' ||\n                     likeButton.classList.contains('artdeco-button--primary') ||\n                     likeButton.querySelector('[data-test-icon=\"thumbs-up-filled-icon\"]') ||\n                     likeButton.textContent.toLowerCase().includes('liked');\n\n      if (isLiked) {\n        this.log(`Post by ${postData.author} already liked, skipping`);\n        return;\n      }\n\n      // Click the like button\n      likeButton.click();\n      await this.delay(this.getRandomDelay(0.3, 1) * 1000);\n\n      // Verify the like was successful\n      const nowLiked = likeButton.getAttribute('aria-pressed') === 'true' ||\n                      likeButton.classList.contains('artdeco-button--primary') ||\n                      likeButton.querySelector('[data-test-icon=\"thumbs-up-filled-icon\"]');\n\n      if (!nowLiked) {\n        this.log(`Warning: Could not verify like on post by ${postData.author}`);\n      }\n\n    } catch (error) {\n      throw new Error(`Failed to like post: ${error.message}`);\n    }\n  }\n\n  getRandomDelay(min = null, max = null) {\n    // Use config delays if no specific range provided\n    const minDelay = min !== null ? min : this.config.delayMin || 2;\n    const maxDelay = max !== null ? max : this.config.delayMax || 8;\n    \n    // Generate random delay between min and max\n    return Math.random() * (maxDelay - minDelay) + minDelay;\n  }\n\n  generatePostId(content, element) {\n    // Create a simple hash from content and element position\n    const text = content.substring(0, 100);\n    const position = Array.from(element.parentNode.children).indexOf(element);\n    return btoa(text + position).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);\n  }\n\n  async processPost(postData, actions) {\n    this.log(`Processing post by ${postData.author} (${actions.join(', ')})...`);\n    this.updateStatus(`Processing post by ${postData.author}`);\n\n    const result = { liked: false, commented: false };\n\n    // Scroll to post\n    postData.element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    await this.delay(this.getRandomDelay(1, 2) * 1000);\n\n    // Process actions in random order to appear more human\n    const shuffledActions = [...actions].sort(() => Math.random() - 0.5);\n\n    for (const action of shuffledActions) {\n      if (!this.isRunning) break;\n\n      try {\n        if (action === 'like' && !postData.alreadyLiked) {\n          await this.likePost(postData);\n          result.liked = true;\n          this.updateStats({ postsLiked: this.stats.postsLiked + 1 });\n          this.log(`‚úì Liked post by ${postData.author}`, 'success');\n          \n          // Random delay between actions\n          if (shuffledActions.length > 1) {\n            await this.delay(this.getRandomDelay(0.5, 2) * 1000);\n          }\n        } else if (action === 'like' && postData.alreadyLiked) {\n          this.log(`‚è≠Ô∏è Already liked post by ${postData.author}`, 'info');\n        }\n\n        if (action === 'comment' && !postData.alreadyCommented) {\n          const commentResult = await this.generateComment(postData.content);\n          \n          if (commentResult && commentResult.skip) {\n            this.log(`‚è≠Ô∏è Skipped post by ${postData.author}: ${commentResult.reason}`, 'info');\n          } else if (commentResult && commentResult.comment) {\n            await this.postComment(postData, commentResult.comment);\n            result.commented = true;\n            this.updateStats({ commentsPosted: this.stats.commentsPosted + 1 });\n            this.log(`‚úì Commented on post by ${postData.author}: \"${commentResult.comment.substring(0, 30)}...\"`, 'success');\n          } else {\n            this.log(`Failed to generate comment for post by ${postData.author}`, 'error');\n          }\n        }\n      } catch (error) {\n        this.log(`Error with ${action} on post by ${postData.author}: ${error.message}`, 'error');\n      }\n    }\n\n    return result;\n  }\n\n  async generateComment(postContent) {\n    return new Promise((resolve, reject) => {\n      chrome.runtime.sendMessage({\n        type: 'GENERATE_COMMENT',\n        postContent: postContent,\n        commentStyle: this.config.commentStyle,\n        apiKey: this.config.apiKey\n      }, (response) => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message));\n          return;\n        }\n\n        if (response.success) {\n          resolve(response.result);\n        } else {\n          reject(new Error(response.error || 'Failed to generate comment'));\n        }\n      });\n    });\n  }\n\n  async postComment(postData, comment) {\n    try {\n      // Scroll post into view\n      postData.element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      await this.delay(CONFIG.DELAYS.SCROLL);\n\n      // Click comment button\n      postData.commentButton.click();\n      await this.delay(CONFIG.DELAYS.CLICK);\n\n      // Wait for comment editor to appear\n      const commentEditor = await this.waitForElement(\n        '.comments-comment-texteditor .ql-editor, .comments-comment-texteditor div[contenteditable=\"true\"], .comments-comment-box__form div[contenteditable=\"true\"], .ql-editor[contenteditable=\"true\"]',\n        3000,\n        postData.element\n      );\n\n      if (!commentEditor) {\n        throw new Error('Comment editor not found');\n      }\n\n      // Focus and type comment\n      commentEditor.focus();\n      await this.delay(CONFIG.DELAYS.FOCUS);\n\n      // Clear any existing content\n      commentEditor.innerHTML = '';\n      \n      // Type the comment\n      await this.typeText(commentEditor, comment);\n      await this.delay(CONFIG.DELAYS.TYPE);\n\n      // Find and click submit button\n      const submitButton = await this.waitForElement(\n        '.comments-comment-texteditor .comments-comment-texteditor__submit-button:not([disabled]), .comments-comment-box__submit-button:not([disabled]), .comments-comment-texteditor button[type=\"submit\"]:not([disabled]), .artdeco-button--primary:not([disabled])',\n        2000,\n        postData.element\n      );\n\n      if (!submitButton) {\n        throw new Error('Submit button not found or disabled');\n      }\n\n      submitButton.click();\n      await this.delay(CONFIG.DELAYS.SUBMIT);\n\n      // Verify comment was posted\n      await this.verifyCommentPosted(postData.element, comment);\n\n    } catch (error) {\n      throw new Error(`Failed to post comment: ${error.message}`);\n    }\n  }\n\n  async verifyCommentPosted(postElement, expectedComment) {\n    // Wait a bit for the comment to appear\n    await this.delay(2000);\n    \n    // Look for the comment in the comments section\n    const commentsSection = postElement.querySelector('.comments-comments-list') ||\n                           postElement.querySelector('.social-details-social-comments');\n    \n    if (commentsSection) {\n      const comments = commentsSection.querySelectorAll('.comments-comment-item__main-content');\n      \n      for (const commentEl of comments) {\n        const commentText = commentEl.textContent.trim();\n        if (commentText.includes(expectedComment.substring(0, 20))) {\n          return true; // Comment found\n        }\n      }\n    }\n    \n    // If we can't verify, assume it worked (LinkedIn sometimes delays showing comments)\n    this.log('Could not verify comment posting, but assuming success');\n    return true;\n  }\n\n  async typeText(element, text) {\n    // Clear existing content first\n    element.focus();\n    \n    // Use different methods based on editor type\n    if (element.getAttribute('contenteditable') === 'true') {\n      // For contenteditable elements (LinkedIn's rich text editor)\n      element.innerHTML = '';\n      \n      // Insert text and trigger events\n      element.textContent = text;\n      \n      // Trigger input events that LinkedIn expects\n      element.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n      element.dispatchEvent(new Event('keyup', { bubbles: true, cancelable: true }));\n      element.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));\n      \n      // Trigger composition events for better compatibility\n      element.dispatchEvent(new CompositionEvent('compositionstart', { bubbles: true }));\n      element.dispatchEvent(new CompositionEvent('compositionend', { bubbles: true, data: text }));\n      \n    } else {\n      // For regular input elements\n      element.value = text;\n      element.dispatchEvent(new Event('input', { bubbles: true }));\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n    \n    // Final focus and blur to ensure state is correct\n    await this.delay(100);\n    element.blur();\n    await this.delay(100);\n    element.focus();\n  }\n\n  async waitForElement(selector, timeout = 5000, parent = document) {\n    return new Promise((resolve) => {\n      const element = parent.querySelector(selector);\n      if (element) {\n        resolve(element);\n        return;\n      }\n\n      const observer = new MutationObserver(() => {\n        const element = parent.querySelector(selector);\n        if (element) {\n          observer.disconnect();\n          resolve(element);\n        }\n      });\n\n      observer.observe(parent, {\n        childList: true,\n        subtree: true\n      });\n\n      setTimeout(() => {\n        observer.disconnect();\n        resolve(null);\n      }, timeout);\n    });\n  }\n\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  updateStatus(status) {\n    this.sendMessage({ type: 'STATUS_UPDATE', status });\n  }\n\n  updateStats(newStats) {\n    this.stats = { ...this.stats, ...newStats };\n    this.sendMessage({ type: 'STATS_UPDATE', stats: this.stats });\n  }\n\n  log(message, level = 'info') {\n    console.log(`[LinkedIn Bot] ${message}`);\n    this.sendMessage({\n      type: 'LOG_MESSAGE',\n      message: message,\n      level: level\n    });\n  }\n\n  sendMessage(message) {\n    try {\n      chrome.runtime.sendMessage(message);\n    } catch (error) {\n      console.error('Failed to send message:', error);\n    }\n  }\n}\n\n// Initialize bot when script loads\nnew LinkedInBot();\n","size_bytes":26211},"popup.css":{"content":"body {\n  width: 380px;\n  min-height: 580px;\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n  color: #2d3748;\n}\n\n.container {\n  padding: 20px;\n  height: 100vh;\n  box-sizing: border-box;\n  overflow-y: auto;\n}\n\n.header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 24px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.header h2 {\n  margin: 0;\n  background: linear-gradient(135deg, #0077b5, #00a0dc);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n  font-size: 20px;\n  font-weight: 700;\n  display: flex;\n  align-items: center;\n}\n\n.header h2::before {\n  content: \"ü§ñ\";\n  margin-right: 8px;\n  font-size: 18px;\n}\n\n.status {\n  padding: 8px 16px;\n  border-radius: 20px;\n  font-size: 12px;\n  font-weight: 600;\n  background: rgba(231, 243, 248, 0.9);\n  color: #0077b5;\n  border: 1px solid rgba(0, 119, 181, 0.2);\n  backdrop-filter: blur(4px);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n  transition: all 0.3s ease;\n}\n\n.status.running {\n  background: linear-gradient(135deg, #48bb78, #38a169);\n  color: white;\n  box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);\n}\n\n.status.error {\n  background: linear-gradient(135deg, #f56565, #e53e3e);\n  color: white;\n  box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);\n}\n\n.config-section {\n  margin-bottom: 24px;\n  padding: 20px;\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.form-group {\n  margin-bottom: 20px;\n  position: relative;\n}\n\n.form-group label {\n  display: block;\n  margin-bottom: 8px;\n  font-weight: 600;\n  color: #4a5568;\n  font-size: 14px;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.form-group input,\n.form-group select {\n  width: 100%;\n  padding: 12px 16px;\n  border: 2px solid rgba(226, 232, 240, 0.8);\n  border-radius: 12px;\n  font-size: 14px;\n  box-sizing: border-box;\n  background: rgba(255, 255, 255, 0.9);\n  transition: all 0.3s ease;\n  font-family: inherit;\n}\n\n.form-group input:focus,\n.form-group select:focus {\n  outline: none;\n  border-color: #0077b5;\n  box-shadow: 0 0 0 3px rgba(0, 119, 181, 0.1);\n  background: white;\n  transform: translateY(-1px);\n}\n\n.form-group input:hover,\n.form-group select:hover {\n  border-color: rgba(0, 119, 181, 0.5);\n}\n\n.btn {\n  padding: 12px 24px;\n  border: none;\n  border-radius: 12px;\n  cursor: pointer;\n  font-size: 14px;\n  font-weight: 600;\n  transition: all 0.3s ease;\n  font-family: inherit;\n  position: relative;\n  overflow: hidden;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.btn::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: -100%;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);\n  transition: left 0.5s;\n}\n\n.btn:hover::before {\n  left: 100%;\n}\n\n.btn-primary {\n  background: linear-gradient(135deg, #0077b5, #00a0dc);\n  color: white;\n  width: 100%;\n  margin-bottom: 12px;\n  box-shadow: 0 4px 15px rgba(0, 119, 181, 0.3);\n}\n\n.btn-primary:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(0, 119, 181, 0.4);\n}\n\n.btn-primary:disabled {\n  background: #a0aec0;\n  cursor: not-allowed;\n  transform: none;\n  box-shadow: none;\n}\n\n.btn-secondary {\n  background: linear-gradient(135deg, #718096, #4a5568);\n  color: white;\n  width: 100%;\n  box-shadow: 0 4px 15px rgba(113, 128, 150, 0.3);\n}\n\n.btn-secondary:hover:not(:disabled) {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(113, 128, 150, 0.4);\n}\n\n.btn-secondary:disabled {\n  background: #a0aec0;\n  cursor: not-allowed;\n  transform: none;\n  box-shadow: none;\n}\n\n.btn-small {\n  padding: 8px 16px;\n  font-size: 12px;\n  margin-left: 12px;\n  background: linear-gradient(135deg, #48bb78, #38a169);\n  color: white;\n  width: auto;\n  box-shadow: 0 2px 8px rgba(72, 187, 120, 0.3);\n}\n\n.btn-small:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4);\n}\n\n.stats {\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  padding: 20px;\n  margin: 24px 0;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.stat-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n  font-size: 14px;\n  padding: 12px 16px;\n  background: rgba(102, 126, 234, 0.05);\n  border-radius: 10px;\n  border-left: 4px solid #667eea;\n  transition: all 0.3s ease;\n}\n\n.stat-item:hover {\n  transform: translateX(4px);\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);\n}\n\n.stat-item:last-child {\n  margin-bottom: 0;\n}\n\n.stat-label {\n  color: #4a5568;\n  font-weight: 600;\n  display: flex;\n  align-items: center;\n}\n\n.stat-label::before {\n  content: \"üìä\";\n  margin-right: 8px;\n  font-size: 16px;\n}\n\n.stat-item span:last-child {\n  font-weight: 700;\n  color: #667eea;\n  background: rgba(102, 126, 234, 0.1);\n  padding: 4px 12px;\n  border-radius: 20px;\n  min-width: 24px;\n  text-align: center;\n}\n\n.logs {\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  padding: 20px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.logs h4 {\n  margin: 0 0 16px 0;\n  color: #4a5568;\n  font-size: 16px;\n  font-weight: 700;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  display: flex;\n  align-items: center;\n}\n\n.logs h4::before {\n  content: \"üìù\";\n  margin-right: 8px;\n  font-size: 18px;\n}\n\n#logContainer {\n  max-height: 150px;\n  overflow-y: auto;\n  font-size: 13px;\n  color: #4a5568;\n  background: rgba(248, 250, 252, 0.7);\n  border-radius: 12px;\n  padding: 12px;\n}\n\n#logContainer::-webkit-scrollbar {\n  width: 6px;\n}\n\n#logContainer::-webkit-scrollbar-track {\n  background: rgba(226, 232, 240, 0.3);\n  border-radius: 3px;\n}\n\n#logContainer::-webkit-scrollbar-thumb {\n  background: rgba(102, 126, 234, 0.5);\n  border-radius: 3px;\n}\n\n#logContainer::-webkit-scrollbar-thumb:hover {\n  background: rgba(102, 126, 234, 0.7);\n}\n\n.log-entry {\n  padding: 8px 12px;\n  margin-bottom: 4px;\n  border-radius: 8px;\n  background: rgba(255, 255, 255, 0.6);\n  border-left: 3px solid #e2e8f0;\n  transition: all 0.2s ease;\n}\n\n.log-entry:hover {\n  background: rgba(255, 255, 255, 0.9);\n  transform: translateX(2px);\n}\n\n.log-entry:last-child {\n  margin-bottom: 0;\n}\n\n.log-time {\n  color: #a0aec0;\n  font-size: 11px;\n  font-weight: 500;\n}\n\n.log-error {\n  color: #f56565;\n  font-weight: 600;\n}\n\n.log-success {\n  color: #48bb78;\n  font-weight: 600;\n}\n\n.checkbox-group {\n  display: flex;\n  gap: 20px;\n  margin-top: 12px;\n}\n\n.checkbox-label {\n  display: flex;\n  align-items: center;\n  font-weight: 500;\n  margin-bottom: 0;\n  cursor: pointer;\n  padding: 8px 12px;\n  border-radius: 8px;\n  transition: all 0.3s ease;\n  background: rgba(102, 126, 234, 0.05);\n  border: 1px solid rgba(102, 126, 234, 0.1);\n}\n\n.checkbox-label:hover {\n  background: rgba(102, 126, 234, 0.1);\n  transform: translateY(-1px);\n}\n\n.checkbox-label input[type=\"checkbox\"] {\n  width: 18px;\n  height: 18px;\n  margin-right: 8px;\n  margin-bottom: 0;\n  accent-color: #667eea;\n  cursor: pointer;\n}\n\n.controls {\n  background: rgba(255, 255, 255, 0.95);\n  border-radius: 16px;\n  padding: 20px;\n  margin: 24px 0;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n","size_bytes":7718},"popup.js":{"content":"// LinkedIn AI Engagement Bot - Popup Script\n\nclass PopupController {\n  constructor() {\n    this.isRunning = false;\n    this.stats = {\n      postsFound: 0,\n      postsLiked: 0,\n      commentsPosted: 0,\n      errors: 0\n    };\n    \n    this.initializeElements();\n    this.loadStoredData();\n    this.setupEventListeners();\n    this.setupMessageListener();\n  }\n\n  initializeElements() {\n    this.elements = {\n      apiKey: document.getElementById('apiKey'),\n      saveKey: document.getElementById('saveKey'),\n      commentStyle: document.getElementById('commentStyle'),\n      maxPosts: document.getElementById('maxPosts'),\n      enableLikes: document.getElementById('enableLikes'),\n      enableComments: document.getElementById('enableComments'),\n      maxLikes: document.getElementById('maxLikes'),\n      maxComments: document.getElementById('maxComments'),\n      delayMin: document.getElementById('delayMin'),\n      delayMax: document.getElementById('delayMax'),\n      startBot: document.getElementById('startBot'),\n      stopBot: document.getElementById('stopBot'),\n      status: document.getElementById('status'),\n      postsFound: document.getElementById('postsFound'),\n      postsLiked: document.getElementById('postsLiked'),\n      commentsPosted: document.getElementById('commentsPosted'),\n      errors: document.getElementById('errors'),\n      logContainer: document.getElementById('logContainer')\n    };\n  }\n\n  async loadStoredData() {\n    try {\n      const result = await chrome.storage.sync.get([\n        'openaiApiKey',\n        'commentStyle',\n        'maxPosts',\n        'enableLikes',\n        'enableComments',\n        'maxLikes',\n        'maxComments',\n        'delayMin',\n        'delayMax',\n        'stats'\n      ]);\n\n      if (result.openaiApiKey) {\n        this.elements.apiKey.value = result.openaiApiKey;\n      }\n\n      if (result.commentStyle) {\n        this.elements.commentStyle.value = result.commentStyle;\n      }\n\n      if (result.maxPosts) {\n        this.elements.maxPosts.value = result.maxPosts;\n      }\n\n      if (result.enableLikes !== undefined) {\n        this.elements.enableLikes.checked = result.enableLikes;\n      }\n\n      if (result.enableComments !== undefined) {\n        this.elements.enableComments.checked = result.enableComments;\n      }\n\n      if (result.maxLikes) {\n        this.elements.maxLikes.value = result.maxLikes;\n      }\n\n      if (result.maxComments) {\n        this.elements.maxComments.value = result.maxComments;\n      }\n\n      if (result.delayMin) {\n        this.elements.delayMin.value = result.delayMin;\n      }\n\n      if (result.delayMax) {\n        this.elements.delayMax.value = result.delayMax;\n      }\n\n      if (result.stats) {\n        this.stats = { ...this.stats, ...result.stats };\n        this.updateStatsDisplay();\n      }\n    } catch (error) {\n      this.addLog('Error loading stored data: ' + error.message, 'error');\n    }\n  }\n\n  setupEventListeners() {\n    this.elements.saveKey.addEventListener('click', () => this.saveApiKey());\n    this.elements.startBot.addEventListener('click', () => this.startBot());\n    this.elements.stopBot.addEventListener('click', () => this.stopBot());\n    \n    // Save settings on change\n    this.elements.commentStyle.addEventListener('change', () => this.saveSettings());\n    this.elements.maxPosts.addEventListener('change', () => this.saveSettings());\n    this.elements.enableLikes.addEventListener('change', () => this.saveSettings());\n    this.elements.enableComments.addEventListener('change', () => this.saveSettings());\n    this.elements.maxLikes.addEventListener('change', () => this.saveSettings());\n    this.elements.maxComments.addEventListener('change', () => this.saveSettings());\n    this.elements.delayMin.addEventListener('change', () => this.saveSettings());\n    this.elements.delayMax.addEventListener('change', () => this.saveSettings());\n  }\n\n  setupMessageListener() {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      switch (message.type) {\n        case 'STATUS_UPDATE':\n          this.updateStatus(message.status);\n          break;\n        case 'STATS_UPDATE':\n          this.updateStats(message.stats);\n          break;\n        case 'LOG_MESSAGE':\n          this.addLog(message.message, message.level);\n          break;\n        case 'BOT_STOPPED':\n          this.handleBotStopped();\n          break;\n      }\n    });\n  }\n\n  async saveApiKey() {\n    const apiKey = this.elements.apiKey.value.trim();\n    \n    if (!apiKey) {\n      this.addLog('Please enter a valid OpenAI API key', 'error');\n      return;\n    }\n\n    if (!apiKey.startsWith('sk-')) {\n      this.addLog('Invalid OpenAI API key format', 'error');\n      return;\n    }\n\n    try {\n      await chrome.storage.sync.set({ openaiApiKey: apiKey });\n      this.addLog('API key saved successfully', 'success');\n    } catch (error) {\n      this.addLog('Error saving API key: ' + error.message, 'error');\n    }\n  }\n\n  async saveSettings() {\n    try {\n      await chrome.storage.sync.set({\n        commentStyle: this.elements.commentStyle.value,\n        maxPosts: parseInt(this.elements.maxPosts.value),\n        enableLikes: this.elements.enableLikes.checked,\n        enableComments: this.elements.enableComments.checked,\n        maxLikes: parseInt(this.elements.maxLikes.value),\n        maxComments: parseInt(this.elements.maxComments.value),\n        delayMin: parseInt(this.elements.delayMin.value),\n        delayMax: parseInt(this.elements.delayMax.value)\n      });\n    } catch (error) {\n      this.addLog('Error saving settings: ' + error.message, 'error');\n    }\n  }\n\n  async startBot() {\n    const apiKey = this.elements.apiKey.value.trim();\n    \n    if (!apiKey || !apiKey.startsWith('sk-')) {\n      this.addLog('Please save a valid OpenAI API key first', 'error');\n      return;\n    }\n\n    try {\n      // Get current active tab\n      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      \n      if (!tab.url.includes('linkedin.com')) {\n        this.addLog('Please navigate to LinkedIn first', 'error');\n        return;\n      }\n\n      // Ensure content script is injected and ready\n      try {\n        await chrome.scripting.executeScript({\n          target: { tabId: tab.id },\n          files: ['config.js', 'content.js']\n        });\n        \n        // Small delay to ensure script initialization\n        await new Promise(resolve => setTimeout(resolve, 500));\n      } catch (scriptError) {\n        // Content script might already be loaded, continue\n        console.log('Content script injection result:', scriptError.message);\n      }\n\n      // Test connection with ping\n      try {\n        await chrome.tabs.sendMessage(tab.id, { type: 'PING' });\n      } catch (pingError) {\n        throw new Error('Content script not responding. Please refresh the LinkedIn page and try again.');\n      }\n\n      // Send start message to content script\n      await chrome.tabs.sendMessage(tab.id, {\n        type: 'START_BOT',\n        config: {\n          apiKey: apiKey,\n          commentStyle: this.elements.commentStyle.value,\n          maxPosts: parseInt(this.elements.maxPosts.value),\n          enableLikes: this.elements.enableLikes.checked,\n          enableComments: this.elements.enableComments.checked,\n          maxLikes: parseInt(this.elements.maxLikes.value),\n          maxComments: parseInt(this.elements.maxComments.value),\n          delayMin: parseInt(this.elements.delayMin.value),\n          delayMax: parseInt(this.elements.delayMax.value)\n        }\n      });\n\n      this.isRunning = true;\n      this.updateUIState();\n      this.updateStatus('Starting bot...');\n      this.addLog('Bot started successfully', 'success');\n      \n    } catch (error) {\n      this.addLog('Error starting bot: ' + error.message, 'error');\n    }\n  }\n\n  async stopBot() {\n    try {\n      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      \n      try {\n        await chrome.tabs.sendMessage(tab.id, { type: 'STOP_BOT' });\n      } catch (messageError) {\n        // Content script might not be responsive, that's ok\n        console.log('Stop message result:', messageError.message);\n      }\n      \n      this.handleBotStopped();\n      this.addLog('Bot stopped', 'success');\n      \n    } catch (error) {\n      this.addLog('Error stopping bot: ' + error.message, 'error');\n      this.handleBotStopped(); // Force stop UI state\n    }\n  }\n\n  handleBotStopped() {\n    this.isRunning = false;\n    this.updateUIState();\n    this.updateStatus('Ready');\n  }\n\n  updateUIState() {\n    this.elements.startBot.disabled = this.isRunning;\n    this.elements.stopBot.disabled = !this.isRunning;\n    this.elements.apiKey.disabled = this.isRunning;\n    this.elements.commentStyle.disabled = this.isRunning;\n    this.elements.maxPosts.disabled = this.isRunning;\n  }\n\n  updateStatus(status) {\n    this.elements.status.textContent = status;\n    this.elements.status.className = 'status';\n    \n    if (status.toLowerCase().includes('error')) {\n      this.elements.status.classList.add('error');\n    } else if (status.toLowerCase().includes('running') || status.toLowerCase().includes('processing')) {\n      this.elements.status.classList.add('running');\n    }\n  }\n\n  updateStats(newStats) {\n    this.stats = { ...this.stats, ...newStats };\n    this.updateStatsDisplay();\n    this.saveStatsToStorage();\n  }\n\n  updateStatsDisplay() {\n    this.elements.postsFound.textContent = this.stats.postsFound || 0;\n    this.elements.postsLiked.textContent = this.stats.postsLiked || 0;\n    this.elements.commentsPosted.textContent = this.stats.commentsPosted || 0;\n    this.elements.errors.textContent = this.stats.errors || 0;\n  }\n\n  async saveStatsToStorage() {\n    try {\n      await chrome.storage.sync.set({ stats: this.stats });\n    } catch (error) {\n      console.error('Error saving stats:', error);\n    }\n  }\n\n  addLog(message, level = 'info') {\n    const logEntry = document.createElement('div');\n    logEntry.className = 'log-entry';\n    \n    const time = new Date().toLocaleTimeString();\n    const timeSpan = document.createElement('span');\n    timeSpan.className = 'log-time';\n    timeSpan.textContent = `[${time}] `;\n    \n    const messageSpan = document.createElement('span');\n    messageSpan.textContent = message;\n    \n    if (level === 'error') {\n      messageSpan.className = 'log-error';\n    } else if (level === 'success') {\n      messageSpan.className = 'log-success';\n    }\n    \n    logEntry.appendChild(timeSpan);\n    logEntry.appendChild(messageSpan);\n    \n    this.elements.logContainer.appendChild(logEntry);\n    this.elements.logContainer.scrollTop = this.elements.logContainer.scrollHeight;\n    \n    // Keep only last 50 entries\n    while (this.elements.logContainer.children.length > 50) {\n      this.elements.logContainer.removeChild(this.elements.logContainer.firstChild);\n    }\n  }\n}\n\n// Initialize popup controller when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  new PopupController();\n});\n","size_bytes":10972},"replit.md":{"content":"# LinkedIn AI Engagement Bot\n\n## Overview\n\nThis is a Chrome browser extension that automates LinkedIn engagement through AI-generated comments. The bot scans LinkedIn feeds, extracts post content, generates contextually appropriate comments using OpenAI's GPT-4o model, and automatically posts them to increase user engagement on the platform. The extension uses a human-like interaction pattern with configurable delays and comment styles to avoid detection as an automated tool.\n\n## Recent Changes (August 22, 2025)\n\n### AI-Powered Smart Engagement System\n- **Smart Adaptive Comments**: AI automatically chooses response style based on post content (job announcements, achievements, insights, personal stories)\n- **Natural Expressions**: Added \"haha\", \"wow\", \"love this\", \"so true\" and professional emojis for authentic engagement\n- **Variable Comment Length**: Comments range from 1-4 lines, with many being short and natural (not every comment is long)\n- **Advertisement Detection**: Automatically skips sponsored posts and ads to avoid spam-like behavior\n- **Engagement Checking**: Detects already liked/commented posts and skips them to prevent duplicate actions\n- **Context-Aware Responses**: Job posts get congratulations, achievements get praise, insights get thoughtful questions\n\n### Advanced Feature Update (August 21, 2025)\n- **Post Liking Feature**: Added automatic post liking with smart detection of already-liked posts\n- **Flexible Action Controls**: Users can now enable/disable likes and comments independently  \n- **Advanced Limits System**: Separate controls for max posts to like (1-100) and comment (1-50)\n- **Human-like Behavior**: Implemented randomized delays between actions (user-configurable range)\n- **Action Randomization**: Bot randomly shuffles like/comment order to appear more natural\n- **Enhanced Statistics**: Added real-time tracking for posts liked in addition to comments posted\n\n### Technical Improvements (August 20, 2025)\n- Fixed browser compatibility issues (removed Node.js process.env usage)\n- Updated LinkedIn DOM selectors for current site structure  \n- Enhanced content extraction with fallback methods\n- Improved comment posting with better rich text editor support\n- Added comprehensive debugging and logging\n- Created test page for API key validation\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Chrome Extension Architecture\n- **Manifest V3 Structure**: Uses service worker background script pattern for modern Chrome extension development\n- **Multi-Script Architecture**: Separates concerns across background.js (API calls), content.js (DOM manipulation), popup.js (UI control), and config.js (settings)\n- **Message Passing System**: Implements Chrome extension message passing between popup, content script, and background service worker for coordinated actions\n\n### Content Script Strategy\n- **DOM Monitoring**: Uses CSS selectors to identify LinkedIn feed posts, comment buttons, and text editors\n- **Human-like Automation**: Implements configurable delays between actions (scrolling, clicking, typing) to mimic human behavior\n- **State Management**: Tracks processed posts to avoid duplicate comments and maintains running statistics\n\n### AI Integration\n- **OpenAI GPT-4o Integration**: Direct API calls to OpenAI's chat completions endpoint for comment generation\n- **Comment Style Customization**: Supports multiple comment styles (professional, casual, insightful, supportive) through prompt engineering\n- **Content Context Awareness**: Extracts post content and generates relevant, contextual responses\n\n### User Interface Design\n- **Popup-based Control Panel**: Browser extension popup provides configuration interface and bot controls\n- **Real-time Status Updates**: Live statistics tracking and status indicators for bot operation\n- **Persistent Settings**: Chrome storage API for saving API keys and user preferences\n\n### Security and Privacy\n- **API Key Management**: Secure storage of OpenAI API key using Chrome's sync storage\n- **Content Script Isolation**: Runs in isolated context on LinkedIn pages without interfering with site functionality\n- **Error Handling**: Comprehensive error management and logging for debugging and user feedback\n\n## External Dependencies\n\n### APIs and Services\n- **OpenAI API**: GPT-4o model for natural language comment generation\n- **Chrome Extensions API**: Storage, messaging, and content script injection capabilities\n\n### Target Platform\n- **LinkedIn Web Platform**: Specifically designed for LinkedIn.com feed interaction and engagement\n- **DOM Selectors**: Relies on LinkedIn's current HTML structure and CSS classes for automation\n\n### Node.js Dependencies\n- **OpenAI Package**: Version 5.13.1 for API client functionality (though primarily used for reference in browser context)\n\n### Browser Requirements\n- **Chrome Browser**: Manifest V3 compatible Chrome browser for extension hosting\n- **LinkedIn Session**: Requires active LinkedIn login session for feed access and comment posting","size_bytes":5059}},"version":1}